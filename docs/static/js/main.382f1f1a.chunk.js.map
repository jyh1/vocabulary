{"version":3,"sources":["components/word.tsx","components/tooltip/index.tsx","components/icon.tsx","components/tags/index.tsx","utils.ts","parser/word.ts","types.ts","parser/query.ts","parser/lexer.ts","components/wordTable/header.tsx","storage/dump.ts","serialize/createBlob.js","serialize/serialize.js","storage/audio.ts","storage/vocab.ts","storage/index.ts","query/expr.ts","query/insert.ts","query/stmt.ts","components/modal/index.tsx","audio/player.ts","audio/recorder.ts","audio/speak.ts","components/wordcard/index.tsx","components/wordTable/wordTable.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["ps","className","map","p","i","wp","key","Piece","text","kana","Description","desc","split","s","children","active","ele","tooltip","props","icon","aria-hidden","TagComponent","tag","onDelete","name","onDoubleClick","tags","onAddition","t","id","allowNew","allowBackspace","tagComponent","autoResize","placeholderText","serializeWordPieces","length","join","getWordStem","printWord","w","content","description","printWordEntries","ws","printWords","value","download","filename","element","document","createElement","setAttribute","encodeURIComponent","style","display","body","appendChild","click","removeChild","Token","lexer","buildLexer","Character","LParen","RParen","apply","tok","v","Text","rep_sc","Annot","kmid","Desc","alt","seq","opt_sc","anno","Pieces","vs","parseWordPieces","input","expectSingleResult","expectEOF","parse","trim","ExprType","AtomType","Op","StmtType","TokenImpl","kind","pos","keep","nextToken","undefined","this","parseNextAvailable","index","rowEnd","columnEnd","LexerImpl","rules","_rules","rule","source","Error","global","indexStart","rowBegin","columnBegin","result","subString","substr","regexp","lastIndex","test","TokenError","slice","token","parseNext","makeVal","type","Atom","constant","b","Const","makeBin","op","l","r","Binop","prev","opparser","Insert","Dump","Clear","Pushtags","Poptags","Delete","Orderby","Slice","True","False","Number","And","Or","Power","Add","Minus","Multiply","Divide","LessEq","GreaterEq","Less","Greater","Equal","Colon","Variable","Tag","Space","Line","WordInfo","Tags","list_sc","nil","kright","words","Boolean","T","Num","Constant","Var","TagExpr","BinopTable","Expr","ExprParser","str","f","reduce","p1","p2","lrec_sc","right","setPattern","SliceIndex","n1","n2","start","end","Stmt","Stmts","EmptyExpr","MainExpr","Query","expr","stmts","parser","parseQuery","query","Buttons","onClick","toggleHide","export","toggleAP","autoplay","NewWord","addWord","init","cancel","useState","rtags","setRtags","descRef","useRef","contRef","setActive","resetEditor","current","focus","cancelEdit","setError","useEffect","error","create","then","e","console","log","filter","_","j","onKeyDown","insertParens","ref","placeholder","metaKey","ctrlKey","Filter","tref","execute","txt","rows","onFocus","onBlur","idx","selectionStart","selectionEnd","dumpInstance","db","a","entries","iterate","push","createBlob","BASE_CHARS","toString","Object","prototype","bufferToString","buffer","bytes","Uint8Array","base64String","substring","serialize","callback","valueType","call","marker","ArrayBuffer","fileReader","FileReader","onload","SERIALIZED_MARKER","readAsArrayBuffer","JSON","stringify","serializePromise","Promise","resolve","reject","res","err","serializeBlobArray","barr","all","audio","localforage","createInstance","dumpAudio","audios","blobStrs","aud","setItem","getAudio","getItem","delAudioWord","removeItem","vocabulary","dumpVocab","saveWord","word","SESSIONCOUNT","Date","now","newword","reviewtime","lastreview","reviewed","updateWord","oldword","update","listWords","cond","updateTags","newtags","Set","keys","delVocabWord","clearWord","clearWords","vocab","delWord","evalExpr","includes","getTime","Math","random","evalAtom","lres","rres","pow","evalBin","executeInsert","insertEntries","forEach","Array","isArray","S","delStmt","clearStmt","changeTags","pushTags","add","popTags","delete","execStmt","compute","values","sort","e1","e2","sortBy","orderbyStmt","composeStmtFuns","fs","ts","onClose","Audio","chunks","blob","Blob","audioURL","window","URL","createObjectURL","src","revokeObjectURL","play","recorder","navigator","mediaDevices","getUserMedia","stream","MediaRecorder","ondataavailable","data","size","setup","save","state","onstop","_save","stop","record","synth","speechSynthesis","speak","utterThis","SpeechSynthesisUtterance","card","Card","_prevWord","prevWord","_nextWord","nextWord","review","_prevUnreviewed","prevUnreviewed","_nextUnreviewed","nextUnreviewed","widx","uncover","setUncover","recording","setRecording","mouseNav","setMouseNav","hasPrev","hasNext","disableCls","cls","A","startNew","changeAction","act","since","momentjs","fromNow","topRef","open","onMouseDown","button","onWheel","deltaY","tabIndex","title","disabled","n","setWords","setAutoplay","useReducer","q","mask","nextMask","_setWIdx","refreshSt","refresh","editing","setEditing","vocabSize","setVocabSize","busy","setBusy","setBuffer","setWIdx","nw","dragProps","onDragEnd","fromIndex","toIndex","item","splice","nodeSelector","handleSelector","wi","ow","editWord","task","Q","newwords","toISOString","activate","del","edit","Fragment","Entry","stopPropagation","valign","Controls","App","onbeforeunload","location","hostname","match","ReactDOM","render","StrictMode","getElementById","serviceWorker","ready","registration","unregister","catch","message"],"mappings":"6MAKe,cAAkB,IAAhBA,EAAe,EAAfA,GACb,OACI,0BAAMC,UAAU,eACXD,EAAGE,KAAI,SAACC,EAAGC,GAAJ,OAAW,kBAAC,EAAD,CAAOC,GAAIF,EAAGG,IAAKF,SAK5CG,EAAQ,SAAC,GAA6B,IAA5BF,EAA2B,EAA3BA,GACZ,GAAkB,kBAAPA,EACP,OAAQ,8BAAOA,GAFoB,IAIhCG,EAAcH,EAAdG,KAAMC,EAAQJ,EAARI,KACb,OAAQ,8BAAOD,EAAP,IAAa,4BAAKC,GAAlB,MAGCC,EAAc,SAAC,GAA2B,IAA1BC,EAAyB,EAAzBA,KACzB,OACI,oCAAGA,EAAKC,MAAM,MAAMV,KAAI,SAACW,EAAGT,GAAJ,OAAU,uBAAGE,IAAKF,GAAIS,QClBvC,G,YAAA,YAA8B,IAA5BC,EAA2B,EAA3BA,SAAUC,EAAiB,EAAjBA,OAAiB,cACjBD,EADiB,GACjCE,EADiC,KAC5BC,EAD4B,KAExC,OACI,yBAAKhB,UAAWc,EAAS,yBAA0B,mBAC/C,yBACId,UAAWc,EAAS,qBAAuB,eAE1CC,GAEL,yBAAKf,UAAU,mBACVgB,MCZF,G,MAAA,SAACC,GAA2B,IAChCC,EAAQD,EAARC,KACP,OAAQ,uCAAOD,EAAP,CAAcjB,UAAS,gBAAWkB,GAAQC,cAAY,Y,iBCE5DC,G,MAAe,SAAC,GAA4D,IAA1DC,EAAyD,EAAzDA,IAAKC,EAAoD,EAApDA,SACzB,OACE,yBAAKtB,UAAU,YACZqB,EAAIE,KACL,0BAAMvB,UAAU,eAAewB,cAAeF,GAA9C,aAWO,cAA0C,IAAxCG,EAAuC,EAAvCA,KAAMH,EAAiC,EAAjCA,SAAUI,EAAuB,EAAvBA,WAE7B,OACI,kBAAC,IAAD,CACID,KAAMA,EAAKxB,KAAI,SAAA0B,GAAC,MAAG,CAACC,GAAID,EAAGJ,KAAMI,MACjCL,SAAUA,EACVI,WAAYA,EACZG,UAAU,EACVC,gBAAgB,EAChBC,aAAcX,EACdY,YAAY,EACZC,gBAAgB,aCzBrB,SAASC,EAAoBnC,GAChC,OAAOA,EAAGE,KAAI,SAAAC,GAAC,MAAe,kBAAJA,EAAcA,IAN1ByB,EAMwCzB,EAAEK,MALlD4B,OAAS,EAAU,IAAMR,EAAI,IAC5BA,GAIyD,IAAMzB,EAAEM,KAAO,IANnF,IAAkBmB,KAMuES,KAAK,IAGvF,SAASC,EAAYtC,GACxB,OAAOA,EAAGE,KAAI,SAAAC,GAAC,MAAe,kBAAJA,EAAcA,EAAIA,EAAEK,QAAM6B,KAAK,IAG7D,SAASE,EAAUC,GACf,IAAMd,EAAOc,EAAEd,KAAKxB,KAAI,SAAA0B,GAAC,MAAI,IAAIA,KAAGS,KAAK,KACzC,MAAO,CAACX,EAAMS,EAAoBK,EAAEC,SAAUD,EAAEE,YAAahB,GAAMW,KAAK,MAO5E,SAASM,EAAiBC,GACtB,MAAO,WALX,SAAoBA,GAChB,OAAOA,EAAG1C,IAAIqC,GAAWF,KAAK,MAIVQ,CAAWD,EAAG1C,KAAI,SAAAsC,GAAC,OAAIA,EAAEM,UAO1C,SAASC,EAASC,EAAkBxC,GACvC,IAAIyC,EAAUC,SAASC,cAAc,KACrCF,EAAQG,aAAa,OAAQ,iCAAmCC,mBAAmB7C,IACnFyC,EAAQG,aAAa,WAAYJ,GACjCC,EAAQK,MAAMC,QAAU,OACxBL,SAASM,KAAKC,YAAYR,GAC1BA,EAAQS,QACRR,SAASM,KAAKG,YAAYV,G,ICnCzBW,E,iBAAAA,O,yBAAAA,I,mBAAAA,I,oBAAAA,M,KAML,IAAMC,EAAQC,qBAAW,CACrB,EAAC,EAAM,UAAWF,EAAMG,WACxB,EAAC,EAAM,OAAQH,EAAMI,QACrB,EAAC,EAAM,OAAQJ,EAAMK,UAKnBF,EAAuBG,gBAAMC,cAAIP,EAAMG,YAAY,SAAAK,GAAC,OAAIA,EAAE5D,QAE1D6D,EAAkBH,gBAAMI,iBAAOP,IAAY,SAAAK,GAAC,OAAEA,EAAE/B,KAAK,OAErDkC,EAAmBC,eAAKL,cAAIP,EAAMI,QAASK,EAAMF,cAAIP,EAAMK,SAE3DQ,EAAkBC,cAAIX,EAAWQ,GAEjChE,EACF2D,gBAAMS,cAAIF,EAAMG,iBAAOL,KACnB,mCAAE3C,EAAF,KAAKiD,EAAL,YAAgBA,EAAO,CAACrE,KAAMoB,EAAGnB,KAAMoE,GAAOjD,KAEzCkD,EACTZ,gBAAMS,cAAIpE,EAAO+D,iBAAO/D,KAAS,mCAAE6D,EAAF,KAAKW,EAAL,YAAcX,GAAd,mBAAoBW,OAElD,SAASC,EAAgBC,GAC5B,OAAOC,6BAAmBC,oBAAUL,EAAOM,MAAMvB,EAAMuB,MAAMH,EAAMI,W,ICd3DC,EAMAC,EAmBAC,EAkCAC,ECvEP7B,E,uBCPC8B,E,WAGF,WACqB7B,EACAoB,EACVU,EACAnF,EACAoF,EACAC,GACR,yBANkBhC,QAMnB,KALmBoB,QAKnB,KAJSU,OAIT,KAHSnF,OAGT,KAFSoF,MAET,KADSC,OACT,KATMC,eASN,E,iDAgBE,YAZuBC,IAAnBC,KAAKF,YACLE,KAAKF,UAAYE,KAAKnC,MAAMoC,mBACxBD,KAAKf,MACLe,KAAKJ,IAAIM,MAAQF,KAAKxF,KAAK4B,OAC3B4D,KAAKJ,IAAIO,OACTH,KAAKJ,IAAIQ,gBAEUL,IAAnBC,KAAKF,YACLE,KAAKF,UAAY,OAIC,OAAnBE,KAAKF,eAAqBC,EAAYC,KAAKF,c,KAIpDO,E,WAEF,WAAmBC,GAAgC,yBAAhCA,QAA+B,KADlDC,YACkD,sBAC3BP,KAAKM,OADsB,IAC9C,2BAA+B,CAAC,IAArBE,EAAoB,QAC3B,GAA0B,MAAtBA,EAAK,GAAGC,OAAO,GACf,MAAM,IAAIC,MAAJ,6EAAgFF,EAAK,GAAGC,SAElG,IAAKD,EAAK,GAAGG,OACT,MAAM,IAAID,MAAJ,wEAA2EF,EAAK,GAAGC,UANnD,8BAS9CT,KAAKO,OAASD,E,kDAGLrB,GAET,OADAe,KAAKM,MAAQN,KAAKO,OACXP,KAAKC,mBAAmBhB,EAAO,EAAG,EAAG,K,gCAG/BA,EAAe2B,EAAoBC,EAAkBC,GAClE,GAAIF,IAAe3B,EAAM7C,OAAzB,CAIA,IACI2E,EAN6G,EAK3GC,EAAY/B,EAAMgC,OAAOL,GALkF,cAO9EZ,KAAKM,OAPyE,IAOjH,2BAA+C,CAAC,IAAD,yBAAnCT,EAAmC,KAA7BqB,EAA6B,KAArBvB,EAAqB,KAE3C,GADAuB,EAAOC,UAAY,EACfD,EAAOE,KAAKJ,GAAY,CACxB,IADwB,EAClBxG,EAAOwG,EAAUC,OAAO,EAAGC,EAAOC,WACpChB,EAASU,EACTT,EAAYU,EAHQ,cAIRtG,GAJQ,IAIxB,2BAAsB,CAClB,OADkB,SAEd,IAAK,KAAM,MACX,IAAK,KAAM2F,IAAUC,EAAY,EAAG,MACpC,QAASA,MARO,8BAYxBW,EAAS,IAAIrB,EAAaM,KAAMf,EAAOU,EAAMnF,EAAM,CAAE0F,MAAOU,EAAYC,WAAUC,cAAaX,SAAQC,aAAaP,GACpH,QAtByG,8BA0BjH,QAAeE,IAAXgB,EACA,MAAM,IAAIM,aACN,CAAEnB,MAAOU,EAAYC,WAAUC,cAAaX,OAAQU,EAAUT,UAAWU,GADvE,oDAE2C7B,EAAMgC,OAAOL,KAM9D,MAHI,YAAYQ,KAAKL,EAAOvG,QACxBwF,KAAKM,MAAQN,KAAKM,MAAMgB,OAAO,IAE5BP,K,yCAIW9B,EAAeiB,EAAeW,EAAkBC,GAEtE,IADA,IAAIS,IACS,CAOT,QAAcxB,KANdwB,EAAQvB,KAAKwB,UACTvC,OACWc,IAAVwB,EAAsBrB,EAAQqB,EAAM3B,IAAIM,MAAQqB,EAAM/G,KAAK4B,YACjD2D,IAAVwB,EAAsBV,EAAWU,EAAM3B,IAAIO,YACjCJ,IAAVwB,EAAsBT,EAAcS,EAAM3B,IAAIQ,YAG/C,OACG,GAAImB,EAAM1B,KACb,OAAO0B,O,KFjEhB,SAASE,EAAc7F,EAAMwC,GAClC,MAAQ,CAACsD,KAAMpC,EAASqC,KAAM/F,IAAGwC,KAE5B,SAASwD,EAAYC,GAC1B,OAAOJ,EAAQlC,EAASuC,MAAOD,GAoB1B,SAASE,EAAQC,GACtB,OAAO,SAACC,EAAGC,GAAJ,MAAW,CAACR,KAAKpC,EAAS6C,MAAOH,KAAIC,IAAGC,O,SAzCrC5C,O,eAAAA,I,kBAAAA,M,cAMAC,O,aAAAA,I,aAAAA,I,kBAAAA,M,cAmBAC,O,aAAAA,I,WAAAA,I,aAAAA,I,iBAAAA,I,mBAAAA,I,uBAAAA,I,iBAAAA,I,eAAAA,I,qBAAAA,I,mBAAAA,I,0BAAAA,I,mBAAAA,M,cAkCAC,O,mBAAAA,I,qBAAAA,I,iBAAAA,I,uBAAAA,I,qBAAAA,I,kBAAAA,M,cCvEP7B,O,mBAAAA,I,mBAAAA,I,mBAAAA,I,aAAAA,I,iBAAAA,I,eAAAA,I,aAAAA,I,WAAAA,I,eAAAA,I,iBAAAA,I,oBAAAA,I,kBAAAA,I,cAAAA,I,kBAAAA,I,oBAAAA,I,wBAAAA,I,kBAAAA,I,gBAAAA,I,sBAAAA,I,oBAAAA,I,0BAAAA,I,wBAAAA,I,oBAAAA,I,kBAAAA,I,sBAAAA,I,kBAAAA,I,wBAAAA,I,sBAAAA,I,kBAAAA,I,iBAAAA,M,KAiCL,ICkE8B0C,EDqBV8B,EAAiBC,EAvF/BxE,GCkEwByC,EDlEL,CACrB,EAAC,EAAM,YAAa1C,EAAM0E,QAC1B,EAAC,EAAM,UAAW1E,EAAM2E,MACxB,EAAC,EAAM,WAAY3E,EAAM4E,OACzB,EAAC,EAAM,cAAe5E,EAAM6E,UAC5B,EAAC,EAAM,aAAc7E,EAAM8E,SAC3B,EAAC,EAAM,YAAa9E,EAAM+E,QAC1B,EAAC,EAAM,aAAc/E,EAAMgF,SAC3B,EAAC,EAAM,WAAYhF,EAAMiF,OACzB,EAAC,EAAM,UAAWjF,EAAMkF,MACxB,EAAC,EAAM,WAAYlF,EAAMmF,OACzB,EAAC,EAAM,gBAAiBnF,EAAMoF,QAC9B,EAAC,EAAM,WAAYpF,EAAMqF,KACzB,EAAC,EAAM,WAAYrF,EAAMsF,IACzB,EAAC,EAAM,SAAUtF,EAAMuF,OACvB,EAAC,EAAM,QAASvF,EAAMwF,KACtB,EAAC,EAAM,QAASxF,EAAMyF,OACtB,EAAC,EAAM,QAASzF,EAAM0F,UACtB,EAAC,EAAM,QAAS1F,EAAM2F,QACtB,EAAC,EAAM,WAAY3F,EAAM4F,QACzB,EAAC,EAAM,WAAY5F,EAAM6F,WACzB,EAAC,EAAM,QAAS7F,EAAM8F,MACtB,EAAC,EAAM,QAAS9F,EAAM+F,SACtB,EAAC,EAAM,WAAY/F,EAAMgG,OACzB,EAAC,EAAM,QAAShG,EAAMiG,OACtB,EAAC,EAAM,mBAAoBjG,EAAMkG,UACjC,EAAC,EAAM,OAAQlG,EAAMI,QACrB,EAAC,EAAM,OAAQJ,EAAMK,QAErB,EAAC,EAAM,mBAAoBL,EAAMmG,KACjC,EAAC,EAAO,UAAWnG,EAAMoG,OACzB,EAAC,EAAM,gBAAiBpG,EAAMqG,OCoCvB,IAAI5D,EAAaC,ID/BtB2D,EAAkB/F,gBAAMC,cAAIP,EAAMqG,OAAO,SAAArI,GAAC,OAAIA,EAAEpB,QAGhD0J,EACFhG,gBAAMS,cAAIsF,EAAMA,IACZ,mCAAExH,EAAF,KAAWC,EAAX,WAA6B,CAACD,QAASuC,EAAgBvC,GAAUC,kBAEnEqH,GAAgB7F,gBAAMC,cAAIP,EAAMmG,MAAM,SAAA3F,GAAC,OAAIA,EAAE5D,KAAKyG,OAAO,MAEzDkD,GAAmBC,kBAAQL,GAAKM,iBAEhC/B,GACFgC,iBAAOnG,cAAIP,EAAM0E,QAASpE,gBAAMI,iBAAOI,cAAIwF,EAAUC,MAAQ,SAAAI,GAAK,MAAG,CAAC7C,KAAM,SAAU6C,aAEpFhC,GACFrE,gBAAMC,cAAIP,EAAM2E,OAAO,iBAAK,CAACb,KAAM,WAGjC8C,GAAU9F,cAAIR,gBAAMC,cAAIP,EAAMkF,OAAO,kBAAI2B,GAAW,MACtCvG,gBAAMC,cAAIP,EAAMmF,QAAQ,kBAAI0B,GAAW,OACrDC,GAAMxG,gBAAMC,cAAIP,EAAMoF,SAAS,SAAApH,GAAC,OAAKA,EAAEpB,QACvCwI,GAAS9E,gBAAMwG,IAAK,SAAA9I,GAAC,OAAI6I,EAAW7I,MACpC+I,GAAWjG,cAAI8F,GAASxB,IACxBc,GAAW5F,gBAAMC,cAAIP,EAAMkG,WAAW,SAAA1F,GAAC,OAAEqG,EAAUA,EAAWG,IAAuBxG,EAAE5D,KAAKyG,OAAO,OACnG4D,GAAU3G,gBAAM6F,IAAK,SAAAnI,GAAC,OAAE6I,EAAUA,EAAWV,IAAuBnI,MACpE+F,GAAkBjD,cAAImG,GAASF,GAAUb,IAEzCgB,GAA4B,CAC9B,CAAC,CAAClH,EAAMuF,MAAOsB,EAAUA,EAAKtB,SAC9B,CAAC,CAACvF,EAAM0F,SAAUmB,EAAUA,EAAKnB,WAAY,CAAC1F,EAAM2F,OAAQkB,EAAUA,EAAKlB,UAC3E,CAAC,CAAC3F,EAAMwF,IAAKqB,EAAUA,EAAKrB,MAAO,CAACxF,EAAMyF,MAAOoB,EAAUA,EAAKpB,SAChE,CACI,CAACzF,EAAMgG,MAAOa,EAAUA,EAAKb,QAC7B,CAAChG,EAAM8F,KAAMe,EAAUA,EAAKf,OAC5B,CAAC9F,EAAM+F,QAASc,EAAUA,EAAKd,UAC/B,CAAC/F,EAAM6F,UAAWgB,EAAUA,EAAKhB,YACjC,CAAC7F,EAAM4F,OAAQiB,EAAUA,EAAKjB,UAElC,CAAC,CAAC5F,EAAMqF,IAAKwB,EAAUA,EAAKxB,OAC5B,CAAC,CAACrF,EAAMsF,GAAIuB,EAAUA,EAAKvB,OAGzB6B,GAAOvE,iBAGTwE,GAFStG,cAAIiD,GAAMnD,eAAKyG,cAAI,KAAMF,GAAME,cAAI,OAWhD,IAAI,IAAJ,QAAoBH,GAApB,kBAA+B,CAA3B,IACMzC,GADM,OALEnI,KAAI,mCAAE0B,EAAF,KAAKsJ,EAAL,YAAYhH,gBAAMC,cAAIvC,IAAI,kBAAIsJ,QAAIC,QAAO,SAACC,EAAIC,GAAL,OAAU3G,cAAI0G,EAAIC,MAE7DjD,EAKQ4C,GALS3C,EAKGA,GAApC2C,GAJOM,kBAAQlD,EAAMzD,cAAI0D,EAAUD,IAAO,SAACH,EAAWsD,GAAZ,OAAqBA,EAAM,GAAGtD,EAAGsD,EAAM,OAOrFR,GAAKS,WAAWR,IAGhB,IAAMrC,GAAsBzE,gBAAMC,cAAIP,EAAM+E,SAAS,iBAAK,CAACjB,KAAM+C,EAAW9B,WACtEH,GAAoBtE,gBAAMC,cAAIP,EAAM4E,QAAQ,iBAAK,CAACd,KAAM+C,EAAWjC,UACnEI,GACF1E,gBAAMoG,iBAAOnG,cAAIP,EAAMgF,SAAUmC,KAC/B,SAAAjI,GAAK,MAAI,CAAC4E,KAAM+C,EAAW7B,QAAS9F,YACpC2I,GAAa9G,cAAIC,iBAAO8F,IAAMvG,cAAIP,EAAMiG,OAAQjF,iBAAO8F,KACvD7B,GAAoB3E,gBACtBoG,iBAAOnG,cAAIP,EAAMiF,OAAQ4C,KACvB,mCAAEC,EAAF,KAASC,GAAT,iBAAkB,CAACjE,KAAM+C,EAAW5B,MAAO+C,MAAOF,EAAIG,IAAKF,MAE3DlD,GAA0BvE,gBAC5BoG,iBAAOnG,cAAIP,EAAM6E,UAAW0B,KAAO,SAAAzI,GAAI,MAAK,CAACgG,KAAM+C,EAAWhC,SAAU/G,WACtEgH,GAAwBxE,gBAC1BoG,iBAAOnG,cAAIP,EAAM8E,SAAUyB,KAAO,SAAAzI,GAAI,MAAK,CAACgG,KAAM+C,EAAW/B,QAAShH,WACpEoK,GAAkBpH,cAAIiE,GAAQC,GAASC,GAAOJ,GAAUC,GAASF,IACjEuD,GAAoBzH,iBAAOwH,IAE3BE,GAAuB9H,gBAAMmG,iBAAO,kBAAII,GAAW,MAEnDwB,GAAsBvH,cAAIqG,GAAMiB,IAEhCE,GAAoBxH,cACpB4D,GACAC,GACArE,gBAAMS,cAAIsH,GAAUF,KAAQ,yCAAoB,CAACrE,KAAM,SAAUyE,KAArC,KAA2CC,MAA3C,UAa3B,IATkBC,GASZC,IATYD,GASOH,GARpB,SAACjH,GAGL,OAAOC,6BAAmBC,oBAAUkH,GAAOjH,MAAMvB,EAAMuB,MAAMH,QErJtD,YAAC/D,GACZ,OACI,yBAAKjB,UAAU,UACX,kBAAC,GAAYiB,GACb,kBAAC,GAAD,CAAQqL,MAAOrL,EAAMqL,UAK3BC,GAAU,SAACtL,GACb,OACI,yBAAKjB,UAAU,kBACX,kBAAC,GAAYiB,GACb,4BAAQuL,QAASvL,EAAMwL,YAAY,kBAAC,EAAD,CAAMvL,KAAK,eAC9C,4BAAQsL,QAASvL,EAAMyL,QAAQ,kBAAC,EAAD,CAAMxL,KAAK,kBAA1C,KACA,4BAAQsL,QAASvL,EAAM0L,UACnB,kBAAC,EAAD,CAAMzL,KAAMD,EAAM2L,SAAW,QAAU,YAMjDC,GAAU,SAAC,GAAoC,IAAnCC,EAAkC,EAAlCA,QAASC,EAAyB,EAAzBA,KAAMC,EAAmB,EAAnBA,OAAmB,EACtBC,mBAAS,IADa,mBACzCC,EADyC,KAClCC,EADkC,KAE1CC,EAAUC,mBACVC,EAAUD,mBAHgC,EAKpBJ,oBAAS,GALW,mBAKzCnM,EALyC,KAKjCyM,EALiC,KAO1CC,EAAc,WAChBF,EAAQG,QAAQ5K,MAAM,GACtBuK,EAAQK,QAAQ5K,MAAM,GACtByK,EAAQG,QAAQC,SAGdC,EAAa,WACfJ,GAAU,GACVK,GAAS,GACTZ,KAGJa,qBAAU,WACO,OAATd,EACAS,KAEAD,GAAU,GACVK,GAAS,GACTR,EAAQK,QAAQ5K,MAAQkK,EAAKtK,YAC7B6K,EAAQG,QAAQ5K,MAAQX,EAAoB6K,EAAKvK,SACjD2K,EAASJ,EAAKtL,SAEnB,CAACsL,IA7B4C,MA+BtBE,oBAAS,GA/Ba,mBA+BzCa,EA/ByC,KA+BlCF,EA/BkC,KAkD1CG,EAAS,WACX,IACI,IAAMvL,EAAUuC,EAAgBuI,EAAQG,QAAQ5K,OAC1CJ,EAAc2K,EAAQK,QAAQ5K,MACpCiK,EAAQ,CAACtK,UAASC,cAAahB,KAAMyL,IACpCc,MAAK,WAAOR,IAA4B,OAATT,GAAeY,OACjD,MAAMM,GACJL,GAAS,GACTM,QAAQC,IAAIF,KAGpB,OACI,kBAAC,EAAD,CAASnN,OAAQA,GACb,4BACI0L,QAAS,kBAAM1L,EAAS6M,IAAeJ,GAAU,IACjDvN,UAAU,OACb,kBAAC,EAAD,CAAMkB,KAAK,UAEZ,yBACAlB,UAAU,gBACN,kBAAC,EAAD,CACIyB,KAAMyL,EACN5L,SAxCD,SAACnB,GACZgN,EAASD,EAAMkB,QAAO,SAACC,EAAGC,GAAJ,OAAQA,IAAInO,OAwCtBuB,WAtCD,SAACL,GACZ8L,EAAS,GAAD,mBAAKD,GAAL,CAAY7L,EAAIE,WAwChB,yBAAKvB,UAAU,SAAf,QACA,2BACIuO,UAxCM,SAACN,GACP,WAARA,EAAE5N,KACFmO,GAAalB,GAEjBM,GAAS,IAqCGa,IAAKnB,EACL7F,KAAK,OACLzH,UAAW8N,EAAQ,mBAAqB,aACxCY,YAAY,wDAEhB,yBAAK1O,UAAU,SAAf,cACA,8BAAUuO,UAxCI,SAACN,IAClBA,EAAEU,SAAWV,EAAEW,UAAsB,UAAVX,EAAE5N,KAC9B0N,KAsC4CU,IAAKrB,IAC7C,yBAAKpN,UAAU,WACX,4BAAQA,UAAU,OAAOwM,QAASuB,GAAQ,kBAAC,EAAD,CAAM7M,KAAK,UACrD,4BAAQlB,UAAU,SAASwM,QAASmB,GAAY,kBAAC,EAAD,CAAMzM,KAAK,aAQzE2N,GAAS,SAAC,GAAyC,IAAxCvC,EAAuC,EAAvCA,MAAuC,EACxBW,oBAAS,GADe,mBAC7CnM,EAD6C,KACrCyM,EADqC,KAE9CuB,EAAOzB,mBACP0B,EAAU,WACZ,GAAID,EAAKrB,QAAS,CACd,IAAMuB,EAAMF,EAAKrB,QAAQ5K,MACzByJ,EAAMD,GAAW2C,MAWzB,OACI,yBAAKhP,UAAU,gBACX,8BACIuO,UAXM,SAACN,GACD,WAAVA,EAAE5N,KACFmO,GAAaM,IAEZb,EAAEU,SAAWV,EAAEW,UAAsB,UAAVX,EAAE5N,KAC9B0O,KAOIN,IAAKK,EACLG,KAAMnO,EAAS,GAAK,EACpB4N,YAAY,cACZQ,QAAS,kBAAI3B,GAAU,IACvB4B,OAAQ,kBAAI5B,GAAU,MAE1B,0BACIvN,UAAU,OACVwM,QAASuC,GACR,kBAAC,EAAD,CAAM7N,KAAK,cAM5B,SAASsN,GAAaC,GAClB,IAAMW,EAAMX,EAAIhB,QAAQ4B,eACxB,GAAY,OAARD,EAAa,CACb,IAAM7O,EAAOkO,EAAIhB,QAAQ5K,MACzB4L,EAAIhB,QAAQ5K,MAAMtC,EAAK8G,MAAM,EAAG+H,GAAO,KAAO7O,EAAK8G,MAAM+H,GACzDX,EAAIhB,QAAQ4B,eAAiBD,EAAM,EACnCX,EAAIhB,QAAQ6B,aAAeF,EAAM,G,yDCtLlC,SAAeG,GAAtB,mC,gDAAO,WAA4BC,GAA5B,gBAAAC,EAAA,6DACCC,EAA2B,GAD5B,SAEGF,EAAGG,SAAQ,SAAC9M,EAAOxC,GACrBqP,EAAQE,KAAK,CAACvP,EAAKwC,OAHpB,gCAKI6M,GALJ,4C,sBC+BQG,IC1BXC,GACA,mEAuBAC,GAAWC,OAAOC,UAAUF,SAoChC,SAASG,GAAeC,GAEpB,IAEIhQ,EAFAiQ,EAAQ,IAAIC,WAAWF,GACvBG,EAAe,GAGnB,IAAKnQ,EAAI,EAAGA,EAAIiQ,EAAMjO,OAAQhC,GAAK,EAE/BmQ,GAAgBR,GAAWM,EAAMjQ,IAAM,GACvCmQ,GAAgBR,IAAwB,EAAXM,EAAMjQ,KAAW,EAAMiQ,EAAMjQ,EAAI,IAAM,GACpEmQ,GACIR,IAA4B,GAAfM,EAAMjQ,EAAI,KAAY,EAAMiQ,EAAMjQ,EAAI,IAAM,GAC7DmQ,GAAgBR,GAA0B,GAAfM,EAAMjQ,EAAI,IAUzC,OAPIiQ,EAAMjO,OAAS,IAAM,EACrBmO,EAAeA,EAAaC,UAAU,EAAGD,EAAanO,OAAS,GAAK,IAC7DiO,EAAMjO,OAAS,IAAM,IAC5BmO,EACIA,EAAaC,UAAU,EAAGD,EAAanO,OAAS,GAAK,MAGtDmO,EAMJ,SAASE,GAAU3N,EAAO4N,GAC7B,IAAIC,EAAY,GAShB,GARI7N,IACA6N,EAAYX,GAASY,KAAK9N,IAQ1BA,IACe,yBAAd6N,GACI7N,EAAMsN,QAC6B,yBAAhCJ,GAASY,KAAK9N,EAAMsN,SAC9B,CAGE,IAAIA,EACAS,EArGY,YAuGZ/N,aAAiBgO,aACjBV,EAAStN,EACT+N,GArGW,SAuGXT,EAAStN,EAAMsN,OAEG,uBAAdO,EACAE,GAxGK,OAyGgB,wBAAdF,EACPE,GAzGM,OA0Ge,+BAAdF,EACPE,GA1Ga,OA2GQ,wBAAdF,EACPE,GA3GM,OA4Ge,yBAAdF,EACPE,GA3GO,OA4Gc,wBAAdF,EACPE,GA9GM,OA+Ge,yBAAdF,EACPE,GA9GO,OA+Gc,0BAAdF,EACPE,GA/GQ,OAgHa,0BAAdF,EACPE,GAhHQ,OAkHRH,EAAS,IAAIhK,MAAM,wCAI3BgK,EAASG,EAASV,GAAeC,SAC9B,GAAkB,kBAAdO,EAA+B,CAEtC,IAAII,EAAa,IAAIC,WAErBD,EAAWE,OAAS,WAEhB,IAAIhG,EA9IO,uBAgJPnI,EAAM4E,KACN,IACAyI,GAAenK,KAAKe,QACxB2J,EAASQ,gBAAgCjG,IAG7C8F,EAAWI,kBAAkBrO,QAE7B,IACI4N,EAASU,KAAKC,UAAUvO,IAC1B,MAAOoL,GACLC,QAAQJ,MAAM,8CAA+CjL,GAE7D4N,EAAS,KAAMxC,IAKpB,SAASoD,GAAiBxO,GAC7B,OAAO,IAAIyO,SAAQ,SAACC,EAASC,GACzBhB,GAAU3N,GAAO,SAAS4O,EAAKC,GACvBA,EACAF,EAAOE,GAEPH,EAAQE,SAMjB,SAAeE,GAAtB,mC,gDAAO,WAAkCC,GAAlC,UAAAnC,EAAA,sEACU6B,QAAQO,IAAID,EAAK3R,IAAIoR,KAD/B,oF,sBA2EP,IC9PMS,GAAQC,KAAYC,eAAe,CACrCzQ,KAAM,UAGH,SAAe0Q,KAAtB,gC,gDAAO,+BAAAxC,EAAA,sEACkBF,GAAauC,IAD/B,cACGI,EADH,OAEGC,EAAWD,EAAOjS,KAAI,mCAAEI,EAAF,YACxBsR,GADwB,MACA3D,MAAK,SAAC7J,GAAD,MAAkB,CAAC9D,EAAK8D,SAHtD,SAIUmN,QAAQO,IAAIM,GAJtB,oF,sEAOA,WAAyB9R,EAAa+R,GAAtC,UAAA3C,EAAA,sEACGqC,GAAMO,QAAQhS,EAAK+R,GADtB,gCAEI/R,GAFJ,4C,sBAKA,SAAeiS,GAAtB,mC,gDAAO,WAAwBjS,GAAxB,gBAAAoP,EAAA,sEACeqC,GAAMS,QAAQlS,GAD7B,YACGoR,EADH,iDAGQA,GAHR,gCAKI,IALJ,4C,sBAQA,SAAee,GAAtB,mC,gDAAO,WAA4BnS,GAA5B,UAAAoP,EAAA,sEACUqC,GAAMW,WAAWpS,GAD3B,oF,sBCvBP,IAAMqS,GAAaX,KAAYC,eAAe,CAC1CzQ,KAAM,eAGH,SAAeoR,KAAtB,gC,gDAAO,uBAAAlD,EAAA,sEACUF,GAAamD,IADvB,oF,sBAKA,SAAeE,GAAtB,qC,gDAAO,WAAwBvS,EAAawS,GAArC,UAAApD,EAAA,sEACGiD,GAAWL,QAAQhS,EAAKwS,GAD3B,gCAEIxS,GAFJ,4C,sBAKP,IAAIyS,GAAe,EAEZ,SAAehG,GAAtB,mC,gDAAO,WAAuB+F,GAAvB,kBAAApD,EAAA,6DACGpP,EAAM0S,KAAKC,MAAMjD,WAAa,IAAO+C,KACrCG,EAFH,2BAEyBJ,GAFzB,IAE+BK,WAAY,EAAGC,WAAY,IAAIJ,KAAQK,UAAU,IAFhF,SAGGR,GAASvS,EAAK4S,GAHjB,gCAII,CAAC5S,MAAKwC,MAAOoQ,IAJjB,4C,sEAOA,WAAwB3I,GAAxB,UAAAmF,EAAA,sEACU6B,QAAQO,IAAIvH,EAAMrK,IAAI6M,KADhC,oF,sBAIA,SAAeuG,GAAtB,qC,gDAAO,WAAwDhT,EAAa4K,GAArE,kBAAAwE,EAAA,sEACmBiD,GAAWH,QAAQlS,GADtC,UACGiT,EADH,YAGaxN,KADVmN,EAAUhI,EAAEqI,IAFf,gCAIOV,GAASvS,EAAK4S,GAJrB,gCAKQA,GALR,gCAOIK,GAPJ,4C,sEAUA,WAA0BjT,GAA1B,gBAAAoP,EAAA,6DACG8D,EAAS,SAAChR,GAIZ,OAHAA,EAAE2Q,YAAc,EAChB3Q,EAAE4Q,WAAa,IAAIJ,KACnBxQ,EAAE6Q,UAAW,EACN7Q,GALR,SAOU8Q,GAAWhT,EAAKkT,GAP1B,oF,sBAmBA,SAAeC,GAAtB,mC,gDAAO,WAAyBrM,GAAzB,kBAAAsI,EAAA,6DACCnF,EAA8B,GAC5BmJ,EAAOtM,GAAe,kBAAI,GAF7B,SAGGuL,GAAW/C,SAAQ,SAAC9M,EAAexC,GACjCoT,EAAK5Q,IACLyH,EAAMsF,KAAK,CAACvP,MAAKwC,aALtB,gCAQIyH,GARJ,4C,sBAWA,SAASoJ,GAAWzI,GACvB,IAAMsI,EAAS,SAAChR,GACZ,IAAMoR,EAAO,YAAO1I,EAAE,IAAI2I,IAAIrR,EAAEd,OAAOoS,QACvC,GAAIF,EAAQxR,QAAUI,EAAEd,KAAKU,OAEzB,OADAI,EAAEd,KAAOkS,EACFpR,GAIf,OAAO,SAAClC,GAAD,OAAiBgT,GAAWhT,EAAKkT,IAmBrC,SAAeO,GAAtB,mC,gDAAO,WAA4BzT,GAA5B,UAAAoP,EAAA,sEACUiD,GAAWD,WAAWpS,GADhC,oF,sEAIA,uBAAAoP,EAAA,sEACUiD,GAAWvQ,SADrB,oF,sBAIA,SAAe4R,GAAtB,mC,gDAAO,WAAyB1T,GAAzB,gBAAAoP,EAAA,6DACG8D,EAAS,SAAChR,GACZ,GAAIA,EAAE6Q,SAEF,OADA7Q,EAAE6Q,UAAW,EACN7Q,GAJZ,SAQU8Q,GAAWhT,EAAKkT,GAR1B,oF,sBAWA,SAAeS,GAAtB,mC,gDAAO,WAA0BH,GAA1B,UAAApE,EAAA,sEACU6B,QAAQO,IAAIgC,EAAK5T,IAAI8T,KAD/B,oF,sEAIA,uBAAAtE,EAAA,sEACgBiD,GAAWmB,OAD3B,OAEHG,GAFG,oD,sECrHA,+BAAAvE,EAAA,sEACiBkD,KADjB,cACGsB,EADH,gBAEiBhC,KAFjB,cAEGH,EAFH,yBAGIX,KAAKC,UAAU,CAAC6C,QAAOnC,WAH3B,4C,sBAMA,SAAeoC,GAAtB,mC,gDAAO,WAAuB7T,GAAvB,UAAAoP,EAAA,sEACG+C,GAAanS,GADhB,uBAEGyT,GAAazT,GAFhB,4C,sBC4CA,SAAS8T,GAASjI,GACrB,OAAO,SAAC3J,GACJ,OAAQ2J,EAAKzE,MACT,KAAK+C,EAAW9C,KACZ,OAtDT,SAAkBvD,EAAW5B,GAChC,OAAQ4B,EAAExC,GACN,KAAK6I,EAAWV,IACZ,OAAOvH,EAAEd,KAAK2S,SAASjQ,EAAEA,GAC7B,KAAKqG,EAAWG,IACZ,OAAQxG,EAAEA,GACN,IAAK,cAAe,OAAO5B,EAAE2Q,WAC7B,IAAK,OAAQ,OAXXzH,EAW2BsH,KAAKC,MAXpBtH,EAW2BnJ,EAAE4Q,WAAWkB,WAV1D5I,EAAKC,GAAN,MAWK,IAAK,OAAQ,OAAO4I,KAAKC,SACzB,IAAK,WAAY,OAAOhS,EAAE6Q,SAC1B,QAAS,MAAM3M,MAAM,oBAAD,OAAqBtC,EAAEA,IAEnD,KAAKqG,EAAW3C,MACZ,OAAO1D,EAAEA,EAjBrB,IAAkBsH,EAAYC,EA0DP8I,CAAStI,EAAM3J,GAC1B,KAAKiI,EAAWtC,MACZ,IAAMuM,EAAON,GAASjI,EAAKlE,EAAdmM,CAAiB5R,GACxBmS,EAAOP,GAASjI,EAAKjE,EAAdkM,CAAiB5R,GAC9B,OAvCT,SAAiBwF,EAAUC,EAAaC,GAC3C,GAAiB,kBAAND,GAA+B,kBAANC,EAChC,OAAQF,GACJ,KAAKyC,EAAKrB,IAAK,OAAOnB,EAAIC,EAC1B,KAAKuC,EAAKpB,MAAO,OAAOpB,EAAIC,EAC5B,KAAKuC,EAAKnB,SAAU,OAAOrB,EAAIC,EAC/B,KAAKuC,EAAKlB,OAAQ,OAAOtB,EAAIC,EAC7B,KAAKuC,EAAKjB,OAAQ,OAAOvB,GAAKC,EAC9B,KAAKuC,EAAKhB,UAAW,OAAOxB,GAAKC,EACjC,KAAKuC,EAAKf,KAAM,OAAOzB,EAAIC,EAC3B,KAAKuC,EAAKd,QAAS,OAAO1B,EAAIC,EAC9B,KAAKuC,EAAKtB,MAAO,OAAOoL,KAAKK,IAAI3M,EAAGC,GAG5C,GAAiB,mBAAND,GAAgC,mBAANC,EACjC,OAAQF,GACJ,KAAKyC,EAAKxB,IAAK,OAAOhB,GAAKC,EAC3B,KAAKuC,EAAKvB,GAAI,OAAOjB,GAAKC,EAIlC,UAAWD,WAAaC,EACpB,OAAQF,GACJ,KAAKyC,EAAKb,MAAO,OAAO3B,IAAMC,EAItC,MAAMxB,MAAM,uCAYOmO,CAAQ1I,EAAKnE,GAAI0M,EAAMC,KC5DvC,SAASG,GAAcC,GAC1B,IAAIrT,EAA+B,GAC/B6I,EAAsB,GAQ1B,OAPAwK,EAAcC,SAAQ,SAAA9G,GACd+G,MAAMC,QAAQhH,GACdA,EAAE8G,SAAQ,SAAApT,GAAWA,KAAKF,SAAeA,EAAKE,GAAaF,EAAKE,GAAK,QAErE2I,EAAMsF,KAAN,2BAAgB3B,GAAhB,IAAmBxM,KAAMuO,OAAO6D,KAAKpS,SHiB1C,SAAP,mCGdWyT,CAAW5K,G,SCRP6K,G,mFAAf,WAAuBxS,GAAvB,UAAA8M,EAAA,sEACU6B,QAAQO,IAAIlP,EAAG1C,KAAI,SAAAsC,GAAC,OAAI2S,GAAU3S,EAAElC,SAD9C,gCAEW,IAFX,4C,+BAKe+U,G,mFAAf,WAAyBzS,GAAzB,UAAA8M,EAAA,+EACW6B,QAAQO,IAAIlP,EAAG1C,KAAI,SAAAsC,GAAC,OAAI2S,GAAY3S,EAAElC,KAAK2N,MAAK,SAAA7J,GAAC,kCAAS5B,GAAT,IAAYM,MAAOsB,YAD/E,4C,sBAIA,SAASkR,GAAWpK,GAChB,OAAO,SAAUxJ,GACb,OAAO,SAACkB,GACJ,OAAO2O,QAAQO,IACXlP,EAAG1C,KAAI,SAAAsC,GAAC,OAAI0I,EAAExJ,EAAFwJ,CAAQ1I,EAAElC,KAAK2N,MAAK,SAAA7J,GAAC,kCAAS5B,GAAT,IAAYM,MAAOsB,aAM7D,IAAMmR,GAAWD,IJ2DjB,SAAkB5T,GAKrB,OAAOiS,IAJO,SAAC9S,GAAmB,IAAD,gBACba,GADa,IAC7B,2BAAqB,CAAC,IAAXE,EAAU,QAAEf,EAAE2U,IAAI5T,IADA,8BAE7B,OAAOf,QI7DF4U,GAAUH,IJkEhB,SAAiB5T,GAKpB,OAAOiS,IAJO,SAAC9S,GAAmB,IAAD,gBACba,GADa,IAC7B,2BAAqB,CAAC,IAAXE,EAAU,QAAEf,EAAE6U,OAAO9T,IADH,8BAE7B,OAAOf,QI9Cf,SAAS8U,GAAS/T,GACd,OAAQA,EAAE8F,MACN,KAAK+C,EAAW9B,OACZ,OAAOyM,GACX,KAAK3K,EAAW7B,QACZ,OApBZ,SAAqBuD,GACjB,IAAMyJ,EAAU,SAACpT,GAAD,OAAoB4R,GAASjI,EAATiI,CAAe5R,EAAEM,QACrD,OAAO,SAACF,GAAD,OAAuB,IAAI2O,SAAQ,SAAAC,GAAO,OAAIA,EARzD,SAAmB9B,EAAQxE,GACvB,IAAM2K,EAAuBnG,EAAExP,KAAI,SAAAgO,GAAC,MAAI,CAAChD,EAAEgD,GAAIA,MAE/C,OADA2H,EAAOC,MAAK,SAACC,EAAIC,GAAL,OAAYD,EAAG,GAAGC,EAAG,MAC1BH,EAAO3V,KAAI,SAAAgO,GAAC,OAAEA,EAAE,MAKsC+H,CAAOrT,EAAIgT,QAkBzDM,CAAYtU,EAAEkB,OACzB,KAAK2H,EAAW5B,MACZ,OAjBO+C,EAiBUhK,EAAEgK,MAjBeC,EAiBRjK,EAAEiK,IAf7B,SAACjJ,GAAD,OACH,IAAI2O,SAAQ,SAAAC,GAAO,OAAIA,EAAQ5O,EAAG0E,WACpBvB,IAAV6F,EAAsB,EAAIA,OAClB7F,IAAR8F,EAAoBjJ,EAAGR,OAASyJ,QAapC,KAAKpB,EAAWhC,SACZ,OAAO8M,GAAS3T,EAAEF,MACtB,KAAK+I,EAAW/B,QACZ,OAAO+M,GAAQ7T,EAAEF,MACrB,KAAK+I,EAAWjC,MACZ,OAAO6M,GAvBnB,IAAmBzJ,EAA2BC,EA2B9C,SAASsK,GAAgBC,GACrB,OAAO,SAACxT,GACJ,IADwB,EACpB8O,EArBQ,SAAA9O,GAAE,OAAK,IAAI2O,SAAQ,SAAAC,GAAO,OAAIA,EAAQ5O,MAqBxCf,CAAGe,GADW,cAETwT,GAFS,IAExB,IAAI,EAAJ,qBAAkB,CAAC,IAATlL,EAAQ,QACdwG,EAAMA,EAAIzD,KAAK/C,IAHK,8BAKxB,OAAOwG,G,gDAIR,WAAyB2E,EAAazT,GAAtC,UAAA8M,EAAA,sEACUyG,GAAgBE,EAAGnW,IAAIyV,IAAvBQ,CAAkCvT,GAD5C,oF,8CCxEQ,I,MAAA,YAA+B,IAA7BH,EAA4B,EAA5BA,QAAS6T,EAAmB,EAAnBA,QACtB,OAAgB,OAAZ7T,EAA2B,qCAE3B,yBACIxC,UAAU,QAEVuO,UAAW,SAAAN,GAAgB,WAARA,EAAE5N,KAAgBgW,MAErC,yBAAKrW,UAAU,iBACVwC,MCXXsP,I,MAAQ,IAAIwE,O,gDAOX,WAAyBjW,GAAzB,oBAAAoP,EAAA,sEACkByF,GAAW7U,GAD7B,QACGkW,EADH,QAEQpU,OAAS,IACVqU,EAAO,IAAIC,KAAKF,EAAS,CAAE,KAAS,2BACpCG,EAAWC,OAAOC,IAAIC,gBAAgBL,GACxC1E,GAAMgF,KACNH,OAAOC,IAAIG,gBAAgBjF,GAAMgF,KAErChF,GAAMgF,IAAMJ,EACZ5E,GAAMkF,QATP,4C,0BCyDMC,GAAW,I,WA3DpB,aAAc,yBAJdA,cAIa,OAHbV,YAGa,OAFbzE,WAEa,OADbzR,SACa,EACT0F,KAAKkR,SAAW,KAChBlR,KAAKwQ,OAAS,GACdxQ,KAAK+L,MAAQ,IAAIwE,MACjBvQ,KAAK1F,IAAM,K,iLAIW,OAAlB0F,KAAKkR,S,gCACgBC,UAAUC,aAAaC,aAAa,CAAEtF,OAAO,I,OAA5DuF,E,OACNtR,KAAKkR,SAAW,IAAIK,cAAcD,GAClCtR,KAAKkR,SAASM,gBAAkB,SAAAtJ,GACxBA,EAAEuJ,KAAKC,KAAO,GACd,EAAKlB,OAAO3G,KAAK3B,EAAEuJ,O,oIAOd,OAAbzR,KAAK1F,ORZV,SAAP,8BQaY6U,CAAYnP,KAAK1F,IAAK0F,KAAKwQ,QAC3BxQ,KAAK1F,IAAM,MAEf0F,KAAKwQ,OAAS,K,wEAILlW,G,kFACH0F,KAAK2R,Q,UACM,OAAb3R,KAAK1F,I,gCACC0F,KAAK4R,O,OAEf5R,KAAK1F,IAAMA,EACP0F,KAAKkR,UACLlR,KAAKkR,SAAStL,MAAM,I,oIAIrB,IAAD,OACE5F,KAAKkR,UAAkC,cAAtBlR,KAAKkR,SAASW,QAC/B7R,KAAKkR,SAASY,OAAS,kBAAM,EAAKC,SAClC/R,KAAKkR,SAASc,U,+BAIb1X,GAAa,IAAD,OACjB,SAAI0F,KAAKkR,UAAkC,cAAtBlR,KAAKkR,SAASW,SAC/B7R,KAAKkR,SAASY,OAAS,WACnB,EAAKC,QACL,EAAKE,OAAO3X,IAEhB0F,KAAKkR,SAASc,QACP,O,MC3DbE,GAAQtB,OAAOuB,gBAEd,SAASC,GAAMxW,GAClB,IAAMyW,EAAY,IAAIC,yBAAyB1W,GAC/CsW,GAAME,MAAMC,GCkBD,gBAACnX,GAAkB,IACvB4R,EAAiB5R,EAAjB4R,KAAMwD,EAAWpV,EAAXoV,QACPiC,EAAgB,OAATzF,EAAgB,KAAQ,kBAAC,GAAS5R,GAC/C,OACI,kBAAC,GAAD,CAAOuB,QAAS8V,EAAMjC,QAASA,KAIjCkC,GAAO,SAAC,GAGiC,IAHhC1F,EAG+B,EAH/BA,KAAgB2F,EAGe,EAHzBC,SAA+BC,EAGN,EAHJC,SACpCtC,EAEwC,EAFxCA,QAASuC,EAE+B,EAF/BA,OAAQ3S,EAEuB,EAFvBA,MAAO2G,EAEgB,EAFhBA,SACViM,EAC0B,EAD1CC,eACgBC,EAA0B,EAA1CC,eACO3Y,EAA6EwS,EAA7ExS,IADmC,EAC0CwS,EAAxEhQ,MAAOL,EADuB,EACvBA,QAASC,EADc,EACdA,YAAahB,EADC,EACDA,KAAM0R,EADL,EACKA,WAAYD,EADjB,EACiBA,WAAYE,EAD7B,EAC6BA,SAChE6F,EAAgBhT,EAAhBgT,KAAM9W,EAAU8D,EAAV9D,OAF6B,EAIZ8K,oBAAS,GAJG,mBAInCiM,EAJmC,KAI1BC,EAJ0B,OAMRlM,oBAAS,GAND,mBAMnCmM,EANmC,KAMxBC,EANwB,OAQVpM,oBAAS,GARC,mBAQnCqM,EARmC,KAQzBC,EARyB,KAUpCC,EAAUP,EAAO,EACjBQ,EAAUR,EAAO9W,EAAS,EAC1BuX,EAAa,SAACvS,EAAewS,GAAhB,OAAgCA,GAAOxS,EAAO,YAAe,KAa1E6P,EAAO,WAAYoC,GHlDtB,SAAP,4BGkDwCQ,CAAYvZ,IAEhDwN,qBAAU,YACD+L,GAAWC,SAASxZ,IAAQuM,GAC7BoK,MAEL,CAAC3W,IAEJ,IAAMyZ,EAAc,SAACC,GAAD,OAAmB,WAE/BZ,GAAW,GACXY,MAEFtB,EAAWqB,EAAatB,GACxBG,EAAWmB,EAAapB,GACxBM,EAAiBc,EAAaf,GAC9BD,EAAiBgB,EAAajB,GAG9BmB,EAAQC,KAAS9G,GAAY+G,UAE7BC,EAAS9M,iBAAO,MAEtBQ,qBAAU,WAAK,IAAD,EACV,UAAAsM,EAAO1M,eAAP,SAAgBC,UACjB,IAqEH,OACI,yBACI1N,UAAWoT,EAAU,4BAA8B,mBACnD7E,UAtEc,SAACN,GACnB,OAAQA,EAAE5N,KACN,IAAK,IACDoY,IACA,MACJ,IAAK,IACDG,IACA,MACJ,IAAK,IACDD,IACA,MACJ,IAAK,IACDQ,GAAYD,GACZ,MACJ,IAAK,IACDJ,IACA,MACJ,IAAK,IACDE,IACA,MACJ,IAAK,IACGI,EAtDRA,IACAC,GAAa,GACbO,GAAWjC,QANVyB,GAAWQ,GAAW5B,OAAO3X,GAAK2N,MAAK,kBAAIqL,GAAa,MA2DrD,MACJ,IAAK,IACDrC,IACA,MACJ,IAAK,IACDL,OAAOyD,KAAP,iCAAsC/X,EAAYwQ,EAAKhQ,MAAML,SAA7D,QAA6E,cAAc,wBAC3F,MACJ,IAAK,IACDmU,OAAOyD,KAAP,mCAAwC/X,EAAYwQ,EAAKhQ,MAAML,UAAY,eAC3E,MACJ,IAAK,IACDoX,GAAQ/G,EAAKhQ,MAAMJ,aACnB,MACJ,IAAK,IACD8W,GAAaD,KAmCjBe,YA/BiB,SAACpM,GACtB,GAAKqL,EACL,OAAQrL,EAAEqM,QACN,KAAK,EAEDtD,IACA,MACJ,KAAK,EAED4B,MAuBJ2B,QAlBiB,SAACtM,GACjBqL,IACDrL,EAAEuM,OAAS,EACPvM,EAAEuM,OAAS,KACXrB,GAAW,GACXS,GAAQ/G,EAAKhQ,MAAMJ,cAInBwL,EAAEuM,QAAU,IAAI7B,MAUpB8B,SAAU,EACVhM,IAAK0L,GAEL,4BAAQna,UAAU,QACVwM,QAAS6J,GADjB,QAGA,yBAAKrW,UAAU,QAAf,YACcga,GAEd,yBAAKha,UAAU,gBAEX,yBAAKA,UAAU,YACX,yBAAKA,UAAW,WAAakZ,EAAU,WAAY,KAC/C,kBAAC,EAAD,CAASnZ,GAAIyC,KAEjB,yBAAKxC,UAAU,QACVyB,EAAKxB,KAAI,SAAC0B,EAAGxB,GAAJ,OAAQ,0BAAME,IAAKF,GAAIwB,OAErC,yBAAK3B,UAAW,eAAiBkZ,EAAU,WAAY,KACnD,kBAAC,EAAD,CAAaxY,KAAM+B,KAEvB,yBAAKzC,UAAU,WACX,4BAAQ0a,MAAM,IAAIC,SAAUvH,EAAU5G,QAASoM,GAA/C,UAA+D1F,KAGvE,yBAAKlT,UAAW0Z,EAAWF,EAAS,YAAahN,QAASiM,EAAUiC,MAAM,KACtE,kBAAC,EAAD,CAAMxZ,KAAK,kBAEf,yBAAKlB,UAAW0Z,EAAWD,EAAS,aAAcjN,QAASmM,EAAU+B,MAAM,KACvE,kBAAC,EAAD,CAAMxZ,KAAK,mBAEf,yBAAKlB,UAAW,SACXiZ,EAAK,EADV,MACgB9W,EACZ,0BAAMnC,UAAW,OAASoZ,EAAY,UAAY,KAAK,kBAAC,EAAD,CAAMlY,KAAK,oB,aC1KvE,eAAgB,mBARd0Z,EAQc,EACD3N,mBAAS,IADT,mBACnB3C,EADmB,KACZuQ,EADY,OAEM5N,oBAAS,GAFf,mBAEnBL,EAFmB,KAETkO,EAFS,OAGDC,sBAXZH,EAW+B,EAV5B,SAACha,EAAWoa,GAAZ,YACNlV,IAANkV,GAAmBpa,EAAI,GAAKga,EAAII,IASY,GAHtB,mBAGnBC,EAHmB,KAGbC,EAHa,OAIDjO,mBAAS,MAJR,mBAInBgM,EAJmB,KAIbkC,EAJa,OAKGlO,oBAAS,GALZ,mBAKnBmO,EALmB,KAKRC,EALQ,OAMIpO,mBAAS,MANb,mBAMnBqO,EANmB,KAMVC,EANU,OAOQtO,mBAAS,GAPjB,mBAOnBuO,EAPmB,KAORC,EAPQ,OAQFxO,oBAAS,GARP,mBAQnByO,EARmB,KAQbC,EARa,OASE1O,mBAAS,KATX,mBASnBkD,EATmB,KASXyL,EATW,KAW1B/N,qBAAU,YVuEP,WAAP,iCUvEmBqH,GAAmBlH,KAAKyN,MAEvC,IAAM1O,EAAO,WAAOmI,KAAclH,MAAK,SAAArL,GAAE,OAAIkY,EAASlY,OAEtDkL,oBAAUd,EAAM,IAEhB,IAAM8O,EAAU,SAAC1b,GACH,OAANA,EAAYgb,EAAS,MAChB,GAAKhb,GAAKA,EAAImK,EAAMnI,QAAQgZ,EAAShb,IAe5C+T,EAAU,SAAC/T,GACb,OAAO,WACH+U,GAAU5K,EAAMnK,GAAGE,KAAK2N,MAAK,WACzB6M,EAASvQ,EAAM8D,QAAO,SAACC,EAAEC,GAAH,OAAOnO,IAAImO,WAKvCsK,EAAS,SAACzY,GACZ,GAAS,OAALA,IAAcmK,EAAMnK,GAAG0C,MAAMuQ,SAAU,CACvC,IAAM/S,EAAMiK,EAAMnK,GAAGE,KVxB1B,SAAP,oCUyBY6U,CAAa7U,GACZ2N,MAAK,SAAC8N,GACHxR,EAAMnK,GAAG,CAACE,MAAKwC,MAAOiZ,GACtBT,GAASD,QAyDfW,EAAY,CACdC,UADc,SACJC,EAAmBC,GACzB,IAAMC,EAAO7R,EAAM8R,OAAOH,EAAW,GAAG,GACxC3R,EAAM8R,OAAOF,EAAS,EAAGC,GACzBd,GAASD,IAEbiB,aAAc,KACdC,eAAgB,KAEpB,OACI,yBAAKtc,WArHgB,EAsHhBib,EAAgB,OAAS,KACzBS,EAAM,QAAU,KAvHG,EAwHnBT,EAAiB,WAAa,KAEnC,yBAAKjb,UAAU,cACX,kBAAC,GAAD,CACI8M,QAAqB,OAAZwO,EApGL,SAAC/Y,GACb,OAAO2S,GAAU3S,GAAGyL,MAAK,SAAAuO,GAAE,OAAI1B,EAAS,CAAC0B,GAAF,mBAASjS,SAGnC,SAACnK,GACd,IAAME,EAAMiK,EAAMnK,GAAGE,IACrB,OAAO,SAACkC,GACJ,OAAO2S,GAAa7U,GAAK,SAAAmc,GAAE,kCAASA,GAAOja,MAC1CyL,MAAK,SAAC8N,GAAMxR,EAAMnK,GAAG0C,MAAMiZ,EAAGT,GAASD,OA4FEqB,CAASnB,GAC/CvO,KAAkB,OAAZuO,EAAmB,KAAOhR,EAAMgR,GAASzY,MAC/CmK,OAAQ,kBAAIuO,EAAW,OACvB9O,WAAY,kBAAIyO,OAASpV,IACzBwG,MAzES,SAACA,GAGlB,IAAIoQ,EACJ,OAFAf,GAAQ,GAEDrP,EAAM7E,MACT,IAAK,SACDiV,EAAOC,GAAgBrQ,EAAMhC,OAAO0D,MAChC,SAAA4O,GACI/B,EAAS,GAAD,mBAAK+B,GAAL,YAAkBtS,QAGlC,MACJ,IAAK,SACDoS,EAAOxH,GAAYyH,GAAWrQ,EAAMJ,OAC/B8B,MAAK,SAAArL,GAAE,ONbrB,SAAP,qCMagCga,CAAYrQ,EAAMH,MAAOxJ,MACpCqL,KAAK6M,GACV,MACJ,IAAK,aACD6B,EV8BT,WAAP,gCU9BuBxH,GAAelH,KAAKjB,GAC3B,MACJ,IAAK,QTzFV,WAAP,iCS0FgBmI,GACClH,MAAK,SAAApN,GAAC,OAAIkC,GAAS,IAAIiQ,MAAO8J,cAAc,OAAQjc,MACrD8b,EAAO,IAAIpL,SAAQ,SAACC,GAAD,OAAWA,OAGtCmL,EAAK1O,MAAK,kBAAI2N,GAAQ,OAgDdjP,OAAQ,WpBvHpB5J,EAAS,YAAaJ,EoBuHqB4H,KAC/BsC,SAAUA,EACVD,SAAU,kBAAImO,GAAalO,MAE/B,yBAAK5M,UAAU,cACVsK,EAAMnI,OADX,WAC2BqZ,EAD3B,oBAGA,kBAAC,KAAsBO,EACvB,2BAAO/b,UAAU,cACb,+BACI,4BACI,oCACA,2CACA,sCAGR,+BACKsK,EAAMjD,MAAM,EAAG8I,GAAQlQ,KAAI,SAACsC,EAAGpC,GAAJ,OACxB,kBAAC,GAAD,CACI0S,KAAMtQ,EACNlC,IAAKkC,EAAElC,IACPyc,SAAU,WAAKjB,EAAQ1b,IACvB4c,IAAK7I,EAAQ/T,GACbyY,OAAQ,kBAAIA,EAAOzY,IACnB6c,KAAM,kBAAIzB,EAAWpb,IACrBiP,IAAKjP,UAMpBgQ,EAAS7F,EAAMnI,OACZ,yBAAKnC,UAAU,OAAOwM,QAAS,WAAKoP,EAAUzL,EAAO,MAArD,aAGE,kBAAC,IAAM8M,SAAP,OAGD,OAAPhE,EACF,kBAAC,GAAD,CACI5C,QAAS,WAAKwF,EAAQ,OACtBlD,SAAU,WAAKkD,EAAQ5C,EAAK,IAC5BR,SAAU,WAAKoD,EAAQ5C,EAAK,IAC5BL,OAAQ,kBAAIA,EAAOK,IACnBpG,KAAMvI,EAAM2O,GACZhT,MAAO,CAACgT,OAAM9W,OAAQmI,EAAMnI,QAC5B2W,eA/Ee,WACnB,GAAa,OAATG,EACA,IAAI,IAAI9Y,EAAI8Y,EAAK,EAAG9Y,GAAK,EAAGA,IACxB,IAAKmK,EAAMnK,GAAG0C,MAAMuQ,SAAS,CACzByI,EAAQ1b,GACR,QA2ER6Y,eA5Fe,WACnB,GAAa,OAATC,EACA,IAAI,IAAI9Y,EAAI8Y,EAAK,EAAG9Y,EAAImK,EAAMnI,OAAQhC,IAClC,IAAKmK,EAAMnK,GAAG0C,MAAMuQ,SAAU,CAC1ByI,EAAQ1b,GACR,QAwFRyM,SAAUA,IACV,uCAMNsQ,GAAQ,SAAC,GAKJ,IAJPrK,EAIM,EAJNA,KAAMiK,EAIA,EAJAA,SAAUC,EAIV,EAJUA,IAAKnE,EAIf,EAJeA,OAAQoE,EAIvB,EAJuBA,KAAM5N,EAI7B,EAJ6BA,IAI7B,EAC+ByD,EAAKhQ,MAAnCL,EADD,EACCA,QAASf,EADV,EACUA,KAAMgB,EADhB,EACgBA,YAChB2Q,EAAWP,EAAKhQ,MAAMuQ,SAC5B,OACI,wBAAI5G,QAASsQ,EAAU9c,UAAWoT,EAAW,WAAa,IACtD,4BACI,uBAAG5G,QAAS,SAAAyB,GAAC,OAAEA,EAAEkP,qBACjB,yBAAKnd,UAAU,WAAW,kBAAC,EAAD,CAAMD,GAAIyC,MAExC,4BAAI,yBAAKxC,UAAU,eAAeyC,IAClC,wBAAI2a,OAAO,OACP,yBAAKpd,UAAU,QACVyB,EAAKxB,KAAI,SAAC0B,EAAGxB,GAAJ,OAAQ,0BAAME,IAAKF,GAAIwB,QAGzC,wBAAI6K,QAAS,SAAAyB,GAAC,OAAEA,EAAEkP,oBACd,kBAAC,GAAD,CAAU/N,IAAKA,EAAK2N,IAAKA,EAAKnE,OAAQA,EAAQxF,SAAUA,EAAU4J,KAAMA,OAOlFK,GAAW,SAAC,GAKjB,IALkBN,EAKnB,EALmBA,IAAKnE,EAKxB,EALwBA,OAAQxF,EAKhC,EALgCA,SAAU4J,EAK1C,EAL0CA,KAAM5N,EAKhD,EALgDA,IAM5C,OACI,yBAAKpP,UAAU,YACX,4BACIA,UAAU,OACVwM,QAASwQ,GACZ,kBAAC,EAAD,CAAM9b,KAAK,aACZ,4BACIlB,UAAU,SACVwM,QAASoM,GACZ,kBAAC,EAAD,CAAM1X,KAAMkS,EAAW,YAAc,UACtC,4BACIpT,UAAU,SACVwB,cAAeub,GACd,kBAAC,EAAD,CAAM7b,KAAK,eAEhB,0BAAMlB,UAAU,aAAaoP,EAAI,K,OC/O9BkO,OATf,WAEE,OADA3G,OAAO4G,eAAiB,WAAa,MAAO,2BAE1C,yBAAKvd,UAAU,OACb,kBAAC,GAAD,QCGcuK,QACW,cAA7BoM,OAAO6G,SAASC,UAEe,UAA7B9G,OAAO6G,SAASC,UAEhB9G,OAAO6G,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,GAAD,OAEF5a,SAAS6a,eAAe,SDiIpB,kBAAmB5G,WACrBA,UAAU6G,cAAcC,MACrBhQ,MAAK,SAAAiQ,GACJA,EAAaC,gBAEdC,OAAM,SAAArQ,GACLI,QAAQJ,MAAMA,EAAMsQ,a","file":"static/js/main.382f1f1a.chunk.js","sourcesContent":["import React from 'react'\nimport * as T from '../types'\n\ntype Props = {ps: T.WordPieces}\n\nexport default ({ps}: Props) => {\n    return(\n        <span className=\"word-pieces\">\n            {ps.map((p, i) => (<Piece wp={p} key={i}/>))}\n        </span>\n    )\n}\n\nconst Piece = ({wp}: {wp: T.WordPiece}) => {\n    if (typeof wp === \"string\"){\n        return (<ruby>{wp}</ruby>)\n    }\n    const {text, kana} = wp\n    return (<ruby>{text} <rt>{kana}</rt> </ruby>)\n}\n\nexport const Description = ({desc}:{desc: string}) => {\n    return(\n        <>{desc.split(\"\\n\").map((s, i) => <p key={i}>{s}</p>)}</>\n    )\n}","import React, {useState} from 'react'\nimport './tooltip.scss'\n\ntype Props = {children: [JSX.Element, JSX.Element], active: boolean}\n\nexport default ({children, active}: Props)=>{\n    const [ele, tooltip] = children\n    return(\n        <div className={active ? \"tooltip-wrapper active\": \"tooltip-wrapper\"}>\n            <div \n                className={active ? \"tooltip-ele active\" : \"tooltip-ele\"} \n            >\n                {ele}\n            </div>\n            <div className=\"tooltip-tooltip\">\n                {tooltip}\n            </div>\n        </div>\n    )\n}","import React from 'react'\nimport '@fortawesome/fontawesome-free/css/all.css'\n\nexport default (props: {icon: string}) => {\n    const {icon} = props\n    return (<i {...props} className={`fa fa-${icon}`} aria-hidden=\"true\" />)\n}","import React from 'react'\nimport ReactTags from 'react-tag-autocomplete'\n\nimport './tags.scss'\n\n\n\nconst TagComponent = ({ tag, onDelete}: {tag: {name: string}, onDelete: any}) => {\n    return (\n      <div className=\"word-tag\">\n        {tag.name}\n        <span className=\"word-tag-del\" onDoubleClick={onDelete}>✕</span>\n      </div>\n    )\n}\n\ntype Props = {\n      tags: string[]\n    , onDelete: (i:number)=>void\n    , onAddition: (tag: {name: string})=>void\n    }\n\nexport default ({tags, onDelete, onAddition}: Props) => {\n\n    return(\n        <ReactTags \n            tags={tags.map(t=>({id: t, name: t}))}\n            onDelete={onDelete}\n            onAddition={onAddition}\n            allowNew={true}\n            allowBackspace={false}\n            tagComponent={TagComponent}\n            autoResize={true}\n            placeholderText=\"       \"\n        />\n    )\n}","\nimport * as T from './types'\n\nfunction optParen(t: string){\n    if (t.length > 1) return \"(\" + t + \")\"\n    return t\n}\n\nexport function serializeWordPieces(ps: T.WordPieces): string {\n    return ps.map(p => typeof p===\"string\"? p : (optParen(p.text) + \"(\" + p.kana + \")\")).join('')\n}\n\nexport function getWordStem(ps: T.WordPieces): string {\n    return ps.map(p => typeof p===\"string\"? p : p.text).join('')\n}\n\nfunction printWord(w: T.WordInfo): string{\n    const tags = w.tags.map(t => '#'+t).join(' ')\n    return [tags, serializeWordPieces(w.content), w.description, tags].join('\\n')\n}\n\nfunction printWords(ws: T.WordInfo[]): string{\n    return ws.map(printWord).join('\\n')\n}\n\nfunction printWordEntries(ws: T.WordEntry[]): string{\n    return \"Insert\\n\" + printWords(ws.map(w => w.value))\n}\n\nexport function downloadVocabulary(ws: T.WordEntry[]){\n    download(\"query.txt\", printWordEntries(ws))\n}\n\nexport function download(filename: string, text: string) {\n    var element = document.createElement('a');\n    element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));\n    element.setAttribute('download', filename);\n    element.style.display = 'none';\n    document.body.appendChild(element);\n    element.click();\n    document.body.removeChild(element);\n  }\n\n","import { Parser } from 'typescript-parsec';\nimport { buildLexer, expectEOF, expectSingleResult } from 'typescript-parsec';\nimport { opt_sc, apply, kmid, rep_sc, seq, alt, tok } from 'typescript-parsec';\nimport * as T from '../types'\n\nenum Token {\n      Character\n    , LParen\n    , RParen\n}\n\nconst lexer = buildLexer([\n    [true, /^[^()]/g, Token.Character],\n    [true, /^\\(/g, Token.LParen],\n    [true, /^\\)/g, Token.RParen],\n])\n\ntype P<T> = Parser<Token, T>\n\nconst Character: P<string> = apply(tok(Token.Character), v => v.text)\n\nconst Text: P<string> = apply(rep_sc(Character), v=>v.join(''))\n\nconst Annot: P<string> = kmid(tok(Token.LParen), Text, tok(Token.RParen))\n\nconst Desc: P<string> = alt(Character, Annot)\n\nconst Piece: P<T.WordPiece> = \n    apply(seq(Desc, opt_sc(Annot)),\n        ([t, anno]) => (anno ? {text: t, kana: anno}: t))\n\nexport const Pieces: P<T.WordPieces> = \n    apply(seq(Piece, rep_sc(Piece)), ([v, vs]) => [v, ...vs])\n\nexport function parseWordPieces(input: string): T.WordPieces{\n    return expectSingleResult(expectEOF(Pieces.parse(lexer.parse(input.trim()))))\n}\n","export type Kanji = {text: string, kana: string}\n\nexport type WordPiece = Kanji | string\n\nexport type WordPieces = WordPiece[]\n\nexport type WordInfo = {\n    content: WordPieces\n  , description: string\n  , tags: string[]\n}\n\nexport type Word = WordInfo & {reviewtime: number, lastreview: Date, reviewed: boolean}\n\nexport type KeyValue<T> = {key: string, value: T}\n\nexport type WordEntry = KeyValue<Word>\n\n\nexport type Tag = string\n\nexport enum ExprType{\n    Atom\n  , Binop\n}\n\n\nexport enum AtomType{\n    Tag\n  , Var\n  , Const\n}\ntype AtomSkelton<T, V> = {type: ExprType.Atom, t: T, v: V}\ntype TagAtm = AtomSkelton<AtomType.Tag, Tag>\ntype VarAtm = AtomSkelton<AtomType.Var, string>\ntype BoolConst = AtomSkelton<AtomType.Const, boolean>\ntype NumConst = AtomSkelton<AtomType.Const, number>\nexport function makeVal<T, V>(t: T, v: V): AtomSkelton<T, V>{\n  return ({type: ExprType.Atom, t, v})\n}\nexport function constant<T>(b: T): AtomSkelton<AtomType.Const, T>{\n  return makeVal(AtomType.Const, b)\n}\nexport type Atom = TagAtm | VarAtm | BoolConst | NumConst\n\n\nexport enum Op {\n  And\n, Or\n, Add\n, Minus\n, Divide\n, Multiply\n, Equal\n, Less\n, Greater\n, LessEq\n, GreaterEq\n, Power\n}\nexport type Binop = {type: ExprType.Binop, op: Op, l: Expr, r: Expr}\nexport function makeBin(op: Op): (l: Expr, r: Expr)=>Binop{\n  return (l, r) => ({type:ExprType.Binop, op, l, r})\n}\n\nexport type Expr = Binop | Atom\n\nexport type Insert = {\n    type: \"Insert\"\n  , words: (Omit<WordInfo, \"tags\"> | Tag[])[]\n}\n\nexport type NewSession = {\n  type: \"NewSession\"\n}\n\nexport type Dump = {\n  type: \"Dump\"\n}\n\nexport enum StmtType{\n    Delete\n  , Orderby\n  , Slice\n  , Pushtags\n  , Poptags\n  , Clear\n}\nexport type Delete = {type: StmtType.Delete}\nexport type Clear = {type: StmtType.Clear}\nexport type Orderby = {type: StmtType.Orderby, value: Expr}\nexport type Slice = {type: StmtType.Slice, start: number | undefined, end: number | undefined}\ntype ChangeTags<T> = {type: T, tags: Tag[]}\nexport type Pushtags = ChangeTags<StmtType.Pushtags>\nexport type Poptags = ChangeTags<StmtType.Poptags>\nexport type Stmt = \n  Delete | Orderby | Slice | Pushtags | Poptags | Clear\n\nexport type Stmts = Stmt[]\n\n\nexport type Filter = {\n    type: \"Filter\"\n  , expr: Expr \n  , stmts: Stmts\n}\n\nexport type Query = Insert | Filter | NewSession | Dump\n\nexport type Result = number | boolean","import { kright, Parser, kleft, list_sc, rule, str, lrec_sc } from 'typescript-parsec';\nimport {expectSingleResult, expectEOF } from 'typescript-parsec';\nimport { opt_sc, nil, apply, kmid, rep_sc, seq, tok, alt } from 'typescript-parsec';\nimport {parseWordPieces} from './word'\nimport {buildLexer} from './lexer'\n// import {buildLexer} from 'typescript-parsec'\nimport * as T from '../types'\n\n\nenum Token {\n      Insert\n    , LParen\n    , RParen\n    , Tag\n    , Space\n    , Line\n    , And\n    , Or\n    , True\n    , False\n    , Number\n    , Power\n    , Add\n    , Minus\n    , Divide\n    , Multiply\n    , Equal\n    , Less\n    , Greater\n    , LessEq\n    , GreaterEq\n    , Variable\n    , Delete\n    , Slice\n    , Orderby\n    , Colon\n    , Pushtags\n    , Poptags\n    , Clear\n    , Dump\n}\n\nconst lexer = buildLexer([\n    [true, /^Insert/gi, Token.Insert],\n    [true, /^Dump/gi, Token.Dump],\n    [true, /^Clear/gi, Token.Clear],\n    [true, /^Pushtags/gi, Token.Pushtags],\n    [true, /^Poptags/gi, Token.Poptags],\n    [true, /^Delete/gi, Token.Delete],\n    [true, /^Orderby/gi, Token.Orderby],\n    [true, /^Slice/gi, Token.Slice],\n    [true, /^true/gi, Token.True],\n    [true, /^false/gi, Token.False],\n    [true, /^\\d+(\\.\\d+)?/g, Token.Number],\n    [true, /^[&]{2}/g, Token.And],\n    [true, /^[|]{2}/g, Token.Or],\n    [true, /^[\\^]/g, Token.Power],\n    [true, /^[+]/g, Token.Add],\n    [true, /^[-]/g, Token.Minus],\n    [true, /^[*]/g, Token.Multiply],\n    [true, /^[/]/g, Token.Divide],\n    [true, /^[<][=]/g, Token.LessEq],\n    [true, /^[>][=]/g, Token.GreaterEq],\n    [true, /^[<]/g, Token.Less],\n    [true, /^[>]/g, Token.Greater],\n    [true, /^[=]{2}/g, Token.Equal],\n    [true, /^[:]/g, Token.Colon],\n    [true, /^\\$[a-zA-Z0-9]+/g, Token.Variable],\n    [true, /^\\(/g, Token.LParen],\n    [true, /^\\)/g, Token.RParen],\n    // keep at last\n    [true, /^\\#[a-zA-Z0-9]+/g, Token.Tag],\n    [false, /^[\\s]+/g, Token.Space],\n    [true, /^[^\\s][^\\n]*/g, Token.Line],\n])\n\ntype P<T> = Parser<Token, T>\n\nconst Line: P<string> = apply(tok(Token.Line), t => t.text)\n\n\nconst WordInfo: P<Omit<T.WordInfo, \"tags\">> = \n    apply(seq(Line, Line),\n        ([content, description]) => ({content: parseWordPieces(content), description}))\n\nconst Tag: P<T.Tag> = apply(tok(Token.Tag), v => v.text.substr(1))\n\nconst Tags: P<T.Tag[]> = list_sc(Tag, nil())\n\nconst Insert: P<T.Insert> = \n    kright(tok(Token.Insert), apply(rep_sc(alt(WordInfo, Tags)), words=>({type: \"Insert\", words})))\n\nconst Dump: P<T.Dump> = \n    apply(tok(Token.Dump), ()=>({type: \"Dump\"}))\n\n// Expression\nconst Boolean = alt(apply(tok(Token.True), ()=>T.constant(true)), \n                    apply(tok(Token.False), ()=>T.constant(false)))\nconst Num = apply(tok(Token.Number), t => +t.text)\nconst Number = apply(Num, t => T.constant(t))\nconst Constant = alt(Boolean, Number)\nconst Variable = apply(tok(Token.Variable), v=>T.makeVal(T.AtomType.Var as T.AtomType.Var, v.text.substr(1)))\nconst TagExpr = apply(Tag, t=>T.makeVal(T.AtomType.Tag as T.AtomType.Tag, t))\nconst Atom: P<T.Atom> = alt(TagExpr, Constant, Variable)\ntype BinopInfo = [Token, (l: T.Expr, r: T.Expr)=>T.Expr]\nconst BinopTable: BinopInfo[][] = [\n    [[Token.Power, T.makeBin(T.Op.Power)]],\n    [[Token.Multiply, T.makeBin(T.Op.Multiply)], [Token.Divide, T.makeBin(T.Op.Divide)]],\n    [[Token.Add, T.makeBin(T.Op.Add)], [Token.Minus, T.makeBin(T.Op.Minus)]],\n    [\n        [Token.Equal, T.makeBin(T.Op.Equal)],\n        [Token.Less, T.makeBin(T.Op.Less)],\n        [Token.Greater, T.makeBin(T.Op.Greater)],\n        [Token.GreaterEq, T.makeBin(T.Op.GreaterEq)],\n        [Token.LessEq, T.makeBin(T.Op.LessEq)],\n    ],\n    [[Token.And, T.makeBin(T.Op.And)]],\n    [[Token.Or, T.makeBin(T.Op.Or)]],\n\n]\nconst Expr = rule<Token, T.Expr>();\nconst Term = alt(Atom, kmid(str('('), Expr, str(')')))\n\nlet ExprParser: P<T.Expr> = Term\n\n\nfunction makeOpParesr(opinfo: BinopInfo[]){\n    return opinfo.map(([t, f]) => apply(tok(t), ()=>f)).reduce((p1, p2)=>alt(p1, p2))\n}\nfunction makeParser(prev: P<T.Expr>, opparser: P<(l:T.Expr, r: T.Expr)=>T.Expr>){\n    return lrec_sc(prev, seq(opparser, prev), (l: T.Expr, right)=> right[0](l, right[1]))\n}\nfor(const opinfo of BinopTable){\n    const opparser = makeOpParesr(opinfo)\n    ExprParser = makeParser(ExprParser, opparser) \n}\n\nExpr.setPattern(ExprParser)\n\n// Statement parser\nconst Delete: P<T.Delete> = apply(tok(Token.Delete), ()=>({type: T.StmtType.Delete}))\nconst Clear: P<T.Clear> = apply(tok(Token.Clear), ()=>({type: T.StmtType.Clear}))\nconst Orderby: P<T.Orderby> = \n    apply(kright(tok(Token.Orderby), Expr)\n    , value =>({type: T.StmtType.Orderby, value}))\nconst SliceIndex = seq(opt_sc(Num), tok(Token.Colon), opt_sc(Num))\nconst Slice: P<T.Slice> = apply(\n    kright(tok(Token.Slice), SliceIndex)\n    , ([n1, _, n2]) => ({type: T.StmtType.Slice, start: n1, end: n2})\n    )\nconst Pushtags: P<T.Pushtags> = apply(\n    kright(tok(Token.Pushtags), Tags), tags => ({type: T.StmtType.Pushtags, tags}))\nconst Poptags: P<T.Poptags> = apply(\n    kright(tok(Token.Poptags), Tags), tags => ({type: T.StmtType.Poptags, tags}))\nconst Stmt: P<T.Stmt> = alt(Delete, Orderby, Slice, Pushtags, Poptags, Clear)\nconst Stmts: P<T.Stmts> = rep_sc(Stmt)\n\nconst EmptyExpr: P<T.Expr> = apply(nil(), ()=>T.constant(true))\n\nconst MainExpr: P<T.Expr> = alt(Expr, EmptyExpr)\n\nconst Query: P<T.Query> = alt(\n      Insert\n    , Dump\n    , apply(seq(MainExpr, Stmts), ([expr, stmts]) => ({type: \"Filter\", expr, stmts}))\n    )\n\n\nexport function parse<T>(parser: P<T>) {\n    return ((input: string) => {\n        // const res = expectEOF(parser.parse(lexer.parse(input)))\n        // console.log(res.successful ? res.candidates : res.error)\n        return expectSingleResult(expectEOF(parser.parse(lexer.parse(input))));\n    }\n    );\n}\n\nexport const parseQuery = parse(Query)\n","import { Lexer, Token, TokenPosition, TokenError } from 'typescript-parsec';\n\nclass TokenImpl<T> implements Token<T> {\n    private nextToken: Token<T> | undefined | null;\n\n    constructor(\n        private readonly lexer: LexerImpl<T>,\n        private readonly input: string,\n        public kind: T,\n        public text: string,\n        public pos: TokenPosition,\n        public keep: boolean\n    ) {\n    }\n\n    public get next(): Token<T> | undefined {\n        if (this.nextToken === undefined) {\n            this.nextToken = this.lexer.parseNextAvailable(\n                this.input,\n                this.pos.index + this.text.length,\n                this.pos.rowEnd,\n                this.pos.columnEnd\n            );\n            if (this.nextToken === undefined) {\n                this.nextToken = null;\n            }\n        }\n\n        return this.nextToken === null ? undefined : this.nextToken;\n    }\n}\n\nclass LexerImpl<T> implements Lexer<T> {\n    _rules: [boolean, RegExp, T][]\n    constructor(public rules: [boolean, RegExp, T][]) {\n        for (const rule of this.rules) {\n            if (rule[1].source[0] !== '^') {\n                throw new Error(`Regular expression patterns for a tokenizer should start with \"^\": ${rule[1].source}`);\n            }\n            if (!rule[1].global) {\n                throw new Error(`Regular expression patterns for a tokenizer should be global: ${rule[1].source}`);\n            }\n        }\n        this._rules = rules\n    }\n\n    public parse(input: string): TokenImpl<T> | undefined {\n        this.rules = this._rules\n        return this.parseNextAvailable(input, 0, 1, 1);\n    }\n\n    public parseNext(input: string, indexStart: number, rowBegin: number, columnBegin: number): TokenImpl<T> | undefined {\n        if (indexStart === input.length) {\n            return undefined;\n        }\n\n        const subString = input.substr(indexStart);\n        let result: TokenImpl<T> | undefined;\n        for (const [keep, regexp, kind] of this.rules) {\n            regexp.lastIndex = 0;\n            if (regexp.test(subString)) {\n                const text = subString.substr(0, regexp.lastIndex);\n                let rowEnd = rowBegin;\n                let columnEnd = columnBegin;\n                for (const c of text) {\n                    switch (c) {\n                        case '\\r': break;\n                        case '\\n': rowEnd++; columnEnd = 1; break;\n                        default: columnEnd++;\n                    }\n                }\n\n                result = new TokenImpl<T>(this, input, kind, text, { index: indexStart, rowBegin, columnBegin, rowEnd, columnEnd }, keep);\n                break\n            }\n        }\n\n        if (result === undefined) {\n            throw new TokenError(\n                { index: indexStart, rowBegin, columnBegin, rowEnd: rowBegin, columnEnd: columnBegin },\n                `Unable to tokenize the rest of the input: ${input.substr(indexStart)}`\n            );\n        } else {\n            if (/^insert/gi.test(result.text)){\n                this.rules = this.rules.slice(-3)\n            }\n            return result;\n        }\n    }\n\n    public parseNextAvailable(input: string, index: number, rowBegin: number, columnBegin: number): TokenImpl<T> | undefined {\n        let token: TokenImpl<T> | undefined;\n        while (true) {\n            token = this.parseNext(\n                input,\n                (token === undefined ? index : token.pos.index + token.text.length),\n                (token === undefined ? rowBegin : token.pos.rowEnd),\n                (token === undefined ? columnBegin : token.pos.columnEnd)\n            );\n            if (token === undefined) {\n                return undefined;\n            } else if (token.keep) {\n                return token;\n            }\n        }\n    }\n}\n\nexport function buildLexer<T>(rules: [boolean, RegExp, T][]): Lexer<T> {\n    return new LexerImpl<T>(rules);\n}","import React, {useState, useRef, useEffect} from 'react'\nimport './header.scss'\nimport Tooltip from '../tooltip'\nimport Icon from '../icon'\nimport Tags from '../tags'\nimport * as T from '../../types'\nimport {serializeWordPieces} from '../../utils'\nimport {parseWordPieces, parseQuery} from '../../parser'\n\n\ntype Props = {\n      addWord: AddWord\n    , init: T.WordInfo | null\n    , cancel: ()=>void\n    , toggleHide: ()=>void\n    , query: (q: T.Query)=>void\n    , export: () => void\n    , autoplay: boolean\n    , toggleAP: ()=>void\n}\n\ntype AddWord = (w: T.WordInfo)=>Promise<void>\n\nexport default (props: Props) => {\n    return(\n        <div className=\"header\">\n            <Buttons {...props}/>\n            <Filter query={props.query}/>\n        </div>\n    )\n}\n\nconst Buttons = (props: Props) =>{\n    return(\n        <div className=\"header-buttons\">\n            <NewWord {...props}/>\n            <button onClick={props.toggleHide}><Icon icon=\"eye-slash\"/></button>\n            <button onClick={props.export}><Icon icon=\"file-download\"/> </button>\n            <button onClick={props.toggleAP}>\n                <Icon icon={props.autoplay ? \"pause\" : \"play\"}/>\n             </button>\n        </div>\n    )\n}\n\nconst NewWord = ({addWord, init, cancel}: Props) => {\n    const [rtags, setRtags] = useState([] as string[])\n    const descRef = useRef() as React.MutableRefObject<HTMLTextAreaElement>\n    const contRef = useRef() as React.MutableRefObject<HTMLInputElement>\n\n    const [active, setActive] = useState(false)\n\n    const resetEditor = () => {\n        contRef.current.value=\"\"\n        descRef.current.value=\"\"\n        contRef.current.focus()\n    }\n\n    const cancelEdit = () => {\n        setActive(false)\n        setError(false)\n        cancel()\n    }\n    \n    useEffect(()=>{\n        if (init === null){\n            resetEditor()\n        } else {\n            setActive(true)\n            setError(false)\n            descRef.current.value = init.description\n            contRef.current.value = serializeWordPieces(init.content)\n            setRtags(init.tags)\n        }\n    }, [init])\n\n    const [error, setError] = useState(false)\n    const delTag = (i:number) =>{\n        setRtags(rtags.filter((_, j)=>j!==i))\n    }\n    const addTag = (tag: {name: string})=>{\n        setRtags([...rtags, tag.name])\n    }\n    const parenShortcut = (e: React.KeyboardEvent) =>{\n        if (e.key===\"Escape\"){\n            insertParens(contRef)\n        }\n        setError(false)\n    }\n\n    const handleTextAreaKey = (e: React.KeyboardEvent) => {\n        if ((e.metaKey || e.ctrlKey) && e.key === \"Enter\"){\n            create()\n        }\n    }\n    const create = () => {\n        try{\n            const content = parseWordPieces(contRef.current.value)\n            const description = descRef.current.value\n            addWord({content, description, tags: rtags})\n            .then(() => {resetEditor(); if (init !== null) cancelEdit()})\n        } catch(e){\n            setError(true)\n            console.log(e)\n        }\n    }\n    return(\n        <Tooltip active={active}>\n            <button \n                onClick={() => active ? cancelEdit() : setActive(true)} \n                className=\"add\"\n            ><Icon icon=\"plus\"/></button>\n\n            <div\n            className=\"newword-form\">\n                <Tags \n                    tags={rtags}\n                    onDelete={delTag}\n                    onAddition={addTag}\n                />\n\n                <div className=\"label\">Word</div>\n                <input \n                    onKeyDown={parenShortcut} \n                    ref={contRef} \n                    type=\"text\" \n                    className={error ? \"word-input error\" : \"word-input\"}\n                    placeholder=\"e.g. 見(み)る. Press [Esc] to insert ()\"\n                />\n                <div className=\"label\">Definition</div>\n                <textarea onKeyDown={handleTextAreaKey} ref={descRef}/>\n                <div className=\"buttons\">\n                    <button className=\"save\" onClick={create}><Icon icon=\"save\"/></button>\n                    <button className=\"cancel\" onClick={cancelEdit}><Icon icon=\"ban\"/></button>\n                </div>\n            </div>\n        </Tooltip>\n    )\n}\n\n\nconst Filter = ({query}: {query: (q:T.Query)=>void}) => {\n    const [active, setActive] = useState(false)\n    const tref = useRef() as React.MutableRefObject<HTMLTextAreaElement>\n    const execute = ()=>{\n        if (tref.current) {\n            const txt = tref.current.value\n            query(parseQuery(txt))\n        }\n    }\n    const onKeyDown = (e: React.KeyboardEvent)=>{\n        if (e.key === \"Escape\"){\n            insertParens(tref)\n        }\n        if ((e.metaKey || e.ctrlKey) && e.key === \"Enter\"){\n            execute()\n        }\n    }\n    return(\n        <div className=\"header-query\">\n            <textarea \n                onKeyDown={onKeyDown}\n                ref={tref}\n                rows={active ? 20 : 1}\n                placeholder=\"Input query\"\n                onFocus={()=>setActive(true)}\n                onBlur={()=>setActive(false)}\n            />\n            <span\n                className=\"icon\"\n                onClick={execute}\n                ><Icon icon=\"search\"/></span>\n        </div>\n    )\n}\n\n\nfunction insertParens(ref: React.MutableRefObject<HTMLInputElement | HTMLTextAreaElement>){\n    const idx = ref.current.selectionStart\n    if (idx !== null){\n        const text = ref.current.value\n        ref.current.value=text.slice(0, idx) + \"()\" + text.slice(idx)\n        ref.current.selectionStart = idx + 1\n        ref.current.selectionEnd = idx + 1\n    }\n}","\nexport async function dumpInstance(db: LocalForage){\n    var entries: [string, any][] = []\n    await db.iterate((value, key)=>{\n        entries.push([key, value])\n    })\n    return entries\n}","// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\nfunction createBlob(parts, properties) {\n    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n    parts = parts || [];\n    properties = properties || {};\n    try {\n        return new Blob(parts, properties);\n    } catch (e) {\n        if (e.name !== 'TypeError') {\n            throw e;\n        }\n        var Builder =\n            typeof BlobBuilder !== 'undefined'\n                ? BlobBuilder\n                : typeof MSBlobBuilder !== 'undefined'\n                  ? MSBlobBuilder\n                  : typeof MozBlobBuilder !== 'undefined'\n                    ? MozBlobBuilder\n                    : WebKitBlobBuilder;\n        var builder = new Builder();\n        for (var i = 0; i < parts.length; i += 1) {\n            builder.append(parts[i]);\n        }\n        return builder.getBlob(properties.type);\n    }\n}\n\nexport default createBlob;","/* eslint-disable no-bitwise */\nimport createBlob from './createBlob';\n\n// Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n// it to Base64, so this is how we store it to prevent very strange errors with less\n// verbose ways of binary <-> string data storage.\nvar BASE_CHARS =\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nvar BLOB_TYPE_PREFIX = '~~local_forage_type~';\nvar BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n\nvar SERIALIZED_MARKER = '__lfsc__:';\nvar SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n\n// OMG the serializations!\nvar TYPE_ARRAYBUFFER = 'arbf';\nvar TYPE_BLOB = 'blob';\nvar TYPE_INT8ARRAY = 'si08';\nvar TYPE_UINT8ARRAY = 'ui08';\nvar TYPE_UINT8CLAMPEDARRAY = 'uic8';\nvar TYPE_INT16ARRAY = 'si16';\nvar TYPE_INT32ARRAY = 'si32';\nvar TYPE_UINT16ARRAY = 'ur16';\nvar TYPE_UINT32ARRAY = 'ui32';\nvar TYPE_FLOAT32ARRAY = 'fl32';\nvar TYPE_FLOAT64ARRAY = 'fl64';\nvar TYPE_SERIALIZED_MARKER_LENGTH =\n    SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n\nvar toString = Object.prototype.toString;\n\nfunction stringToBuffer(serializedString) {\n    // Fill the string into a ArrayBuffer.\n    var bufferLength = serializedString.length * 0.75;\n    var len = serializedString.length;\n    var i;\n    var p = 0;\n    var encoded1, encoded2, encoded3, encoded4;\n\n    if (serializedString[serializedString.length - 1] === '=') {\n        bufferLength--;\n        if (serializedString[serializedString.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n\n    var buffer = new ArrayBuffer(bufferLength);\n    var bytes = new Uint8Array(buffer);\n\n    for (i = 0; i < len; i += 4) {\n        encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\n\n        /*jslint bitwise: true */\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return buffer;\n}\n\n// Converts a buffer to a string to store, serialized, in the backend\n// storage library.\nfunction bufferToString(buffer) {\n    // base64-arraybuffer\n    var bytes = new Uint8Array(buffer);\n    var base64String = '';\n    var i;\n\n    for (i = 0; i < bytes.length; i += 3) {\n        /*jslint bitwise: true */\n        base64String += BASE_CHARS[bytes[i] >> 2];\n        base64String += BASE_CHARS[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64String +=\n            BASE_CHARS[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64String += BASE_CHARS[bytes[i + 2] & 63];\n    }\n\n    if (bytes.length % 3 === 2) {\n        base64String = base64String.substring(0, base64String.length - 1) + '=';\n    } else if (bytes.length % 3 === 1) {\n        base64String =\n            base64String.substring(0, base64String.length - 2) + '==';\n    }\n\n    return base64String;\n}\n\n// Serialize a value, afterwards executing a callback (which usually\n// instructs the `setItem()` callback/promise to be executed). This is how\n// we store binary data with localStorage.\nexport function serialize(value, callback) {\n    var valueType = '';\n    if (value) {\n        valueType = toString.call(value);\n    }\n\n    // Cannot use `value instanceof ArrayBuffer` or such here, as these\n    // checks fail when running the tests using casper.js...\n    //\n    // TODO: See why those tests fail and use a better solution.\n    if (\n        value &&\n        (valueType === '[object ArrayBuffer]' ||\n            (value.buffer &&\n                toString.call(value.buffer) === '[object ArrayBuffer]'))\n    ) {\n        // Convert binary arrays to a string and prefix the string with\n        // a special marker.\n        var buffer;\n        var marker = SERIALIZED_MARKER;\n\n        if (value instanceof ArrayBuffer) {\n            buffer = value;\n            marker += TYPE_ARRAYBUFFER;\n        } else {\n            buffer = value.buffer;\n\n            if (valueType === '[object Int8Array]') {\n                marker += TYPE_INT8ARRAY;\n            } else if (valueType === '[object Uint8Array]') {\n                marker += TYPE_UINT8ARRAY;\n            } else if (valueType === '[object Uint8ClampedArray]') {\n                marker += TYPE_UINT8CLAMPEDARRAY;\n            } else if (valueType === '[object Int16Array]') {\n                marker += TYPE_INT16ARRAY;\n            } else if (valueType === '[object Uint16Array]') {\n                marker += TYPE_UINT16ARRAY;\n            } else if (valueType === '[object Int32Array]') {\n                marker += TYPE_INT32ARRAY;\n            } else if (valueType === '[object Uint32Array]') {\n                marker += TYPE_UINT32ARRAY;\n            } else if (valueType === '[object Float32Array]') {\n                marker += TYPE_FLOAT32ARRAY;\n            } else if (valueType === '[object Float64Array]') {\n                marker += TYPE_FLOAT64ARRAY;\n            } else {\n                callback(new Error('Failed to get type for BinaryArray'));\n            }\n        }\n\n        callback(marker + bufferToString(buffer));\n    } else if (valueType === '[object Blob]') {\n        // Conver the blob to a binaryArray and then to a string.\n        var fileReader = new FileReader();\n\n        fileReader.onload = function() {\n            // Backwards-compatible prefix for the blob type.\n            var str =\n                BLOB_TYPE_PREFIX +\n                value.type +\n                '~' +\n                bufferToString(this.result);\n            callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n        };\n\n        fileReader.readAsArrayBuffer(value);\n    } else {\n        try {\n            callback(JSON.stringify(value));\n        } catch (e) {\n            console.error(\"Couldn't convert value into a JSON string: \", value);\n\n            callback(null, e);\n        }\n    }\n}\n\nexport function serializePromise(value){\n    return new Promise((resolve, reject) => {\n        serialize(value, function(res, err){\n            if (err) {\n                reject(err);\n            } else {\n                resolve(res);\n            }\n        })\n    })\n}\n\nexport async function serializeBlobArray(barr){\n    return await Promise.all(barr.map(serializePromise))\n    \n}\n\n// Deserialize data we've inserted into a value column/field. We place\n// special markers into our strings to mark them as encoded; this isn't\n// as nice as a meta field, but it's the only sane thing we can do whilst\n// keeping localStorage support intact.\n//\n// Oftentimes this will just deserialize JSON content, but if we have a\n// special marker (SERIALIZED_MARKER, defined above), we will extract\n// some kind of arraybuffer/binary data/typed array out of the string.\nfunction deserialize(value) {\n    // If we haven't marked this string as being specially serialized (i.e.\n    // something other than serialized JSON), we can just return it and be\n    // done with it.\n    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n        return JSON.parse(value);\n    }\n\n    // The following code deals with deserializing some kind of Blob or\n    // TypedArray. First we separate out the type of data we're dealing\n    // with from the data itself.\n    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n    var type = value.substring(\n        SERIALIZED_MARKER_LENGTH,\n        TYPE_SERIALIZED_MARKER_LENGTH\n    );\n\n    var blobType;\n    // Backwards-compatible blob type serialization strategy.\n    // DBs created with older versions of localForage will simply not have the blob type.\n    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n        blobType = matcher[1];\n        serializedString = serializedString.substring(matcher[0].length);\n    }\n    var buffer = stringToBuffer(serializedString);\n\n    // Return the right type based on the code/type set during\n    // serialization.\n    switch (type) {\n        case TYPE_ARRAYBUFFER:\n            return buffer;\n        case TYPE_BLOB:\n            return createBlob([buffer], { type: blobType });\n        case TYPE_INT8ARRAY:\n            return new Int8Array(buffer);\n        case TYPE_UINT8ARRAY:\n            return new Uint8Array(buffer);\n        case TYPE_UINT8CLAMPEDARRAY:\n            return new Uint8ClampedArray(buffer);\n        case TYPE_INT16ARRAY:\n            return new Int16Array(buffer);\n        case TYPE_UINT16ARRAY:\n            return new Uint16Array(buffer);\n        case TYPE_INT32ARRAY:\n            return new Int32Array(buffer);\n        case TYPE_UINT32ARRAY:\n            return new Uint32Array(buffer);\n        case TYPE_FLOAT32ARRAY:\n            return new Float32Array(buffer);\n        case TYPE_FLOAT64ARRAY:\n            return new Float64Array(buffer);\n        default:\n            throw new Error('Unkown type: ' + type);\n    }\n}\n\nexport async function deSerializeBlobArray(arr){\n    return await Promise.all(arr.map(deserialize))\n    \n}\n\nvar localforageSerializer = {\n    serialize: serialize,\n    deserialize: deserialize,\n    stringToBuffer: stringToBuffer,\n    bufferToString: bufferToString\n};\n\nexport default localforageSerializer;","import localforage from 'localforage'\nimport {dumpInstance} from './dump'\nimport {serializeBlobArray} from '../serialize'\n\nconst audio = localforage.createInstance({\n    name: \"audio\"\n  });\n\nexport async function dumpAudio(){\n    const audios = await dumpInstance(audio)\n    const blobStrs = audios.map(([key, val]: [string, Blob[]]) => \n        serializeBlobArray(val).then((v: string[]) => ([key, v] as [string, string[]])))\n    return await Promise.all(blobStrs)\n}\n\nexport async function saveAudio(key: string, aud: Blob[]){\n    await audio.setItem(key, aud)\n    return key\n}\n\nexport async function getAudio(key: string){\n    const res = await audio.getItem(key)\n    if (res){\n        return res as Blob[]\n    }\n    return []\n}\n\nexport async function delAudioWord(key: string){\n    return await audio.removeItem(key)\n}","\nimport localforage from 'localforage'\nimport * as T from '../types'\nimport {dumpInstance} from './dump'\n\nconst vocabulary = localforage.createInstance({\n    name: \"vocabulary\"\n  });\n\nexport async function dumpVocab(){\n    return await dumpInstance(vocabulary)\n}\n\n\nexport async function saveWord(key: string, word: T.Word){\n    await vocabulary.setItem(key, word)\n    return key\n}\n\nlet SESSIONCOUNT = 0\n\nexport async function addWord(word: T.WordInfo){\n    const key = Date.now().toString() + \".\" + (SESSIONCOUNT ++)\n    const newword: T.Word = {...word, reviewtime: 1, lastreview: new Date(), reviewed: false}\n    await saveWord(key, newword)\n    return {key, value: newword} as T.KeyValue<T.Word>\n}\n\nexport async function addWords(words: T.WordInfo[]){\n    return await Promise.all(words.map(addWord))\n}\n\nexport async function updateWord<T extends T.Word | undefined>(key: string, f: (w:T.Word)=> T){\n    const oldword = await vocabulary.getItem(key) as T.Word\n    const newword = f(oldword)\n    if (newword !== undefined) {\n        await saveWord(key, newword as T.Word)\n        return newword as T.Word\n    }\n    return oldword\n}\n\nexport async function reviewWord(key: string){\n    const update = (w: T.Word) => {\n        w.reviewtime += 1\n        w.lastreview = new Date()\n        w.reviewed = true\n        return w\n    }\n    return await updateWord(key, update)\n}\n\n\nexport async function updateWordField<K extends keyof T.Word, V extends T.Word[K]>(key: string, field: K, val: V){\n    const update = (w: T.Word) => {\n        w[field] = val\n        return w\n    }\n    return await updateWord(key, update)\n}\n\nexport async function listWords(test ?: (w: T.Word)=>boolean){\n    var words: T.KeyValue<T.Word>[] = []\n    const cond = test ? test : (()=>true)\n    await vocabulary.iterate((value: T.Word, key)=>{\n        if (cond(value)){\n            words.push({key, value})\n        }\n    })\n    return words\n}\n\nexport function updateTags(f: (ts: Set<T.Tag>)=>Set<T.Tag>){\n    const update = (w: T.Word) => {\n        const newtags = [...f(new Set(w.tags)).keys()]\n        if (newtags.length != w.tags.length){\n            w.tags = newtags\n            return w\n        }\n        return undefined\n    }\n    return (key: string) => updateWord(key, update)\n}\n\nexport function pushTags(tags: T.Tag[]){\n    const union = (s: Set<T.Tag>) => {\n        for (const t of tags){ s.add(t)}\n        return s\n    }\n    return updateTags(union)\n}\n\nexport function popTags(tags: T.Tag[]){\n    const minus = (s: Set<T.Tag>) => {\n        for (const t of tags){ s.delete(t)}\n        return s\n    }\n    return updateTags(minus)\n}\n\nexport async function delVocabWord(key: string){\n    return await vocabulary.removeItem(key)\n}\n\nexport async function vocabularySize(){\n    return await vocabulary.length()\n}\n\nexport async function clearWord(key: string){\n    const update = (w: T.Word) => {\n        if (w.reviewed){\n            w.reviewed = false\n            return w\n        }\n        return undefined\n    }\n    return await updateWord(key, update)\n}\n\nexport async function clearWords(keys: string[]){\n    return await Promise.all(keys.map(clearWord))\n}\n\nexport async function newSession(){\n    const keys = await vocabulary.keys()\n    clearWords(keys)\n}","import { delAudioWord, dumpAudio } from './audio'\nimport { delVocabWord, dumpVocab } from './vocab'\n\nexport * from './audio'\nexport * from './vocab'\n\nexport async function dumpDb(){\n    const vocab = await dumpVocab()\n    const audio = await dumpAudio()\n    return JSON.stringify({vocab, audio})\n}\n\nexport async function delWord(key: string){\n    await delAudioWord(key)\n    await delVocabWord(key)\n}","import * as T from '../types';\n\nfunction diffDays(n1: number, n2: number) {\n    return (n1 - n2) / (1000 * 60 * 60 * 24);\n}\n\nexport function evalAtom(v: T.Atom, w: T.Word): T.Result {\n    switch (v.t) {\n        case T.AtomType.Tag:\n            return w.tags.includes(v.v);\n        case T.AtomType.Var:\n            switch (v.v) {\n                case \"totalReview\": return w.reviewtime;\n                case \"days\": return diffDays(Date.now(), w.lastreview.getTime());\n                case \"rand\": return Math.random();\n                case \"reviewed\": return w.reviewed;\n                default: throw Error(`Unknown variable ${v.v}`);\n            }\n        case T.AtomType.Const:\n            return v.v;\n    }\n}\n\n\n\nexport function evalBin(op: T.Op, l: T.Result, r: T.Result): T.Result {\n    if (typeof l === \"number\" && typeof r === \"number\") {\n        switch (op) {\n            case T.Op.Add: return l + r;\n            case T.Op.Minus: return l - r;\n            case T.Op.Multiply: return l * r;\n            case T.Op.Divide: return l / r;\n            case T.Op.LessEq: return l <= r;\n            case T.Op.GreaterEq: return l >= r;\n            case T.Op.Less: return l < r;\n            case T.Op.Greater: return l > r;\n            case T.Op.Power: return Math.pow(l, r)\n        }\n    }\n    if (typeof l === \"boolean\" && typeof r === \"boolean\") {\n        switch (op) {\n            case T.Op.And: return l && r;\n            case T.Op.Or: return l || r;\n        }\n    }\n\n    if (typeof l === typeof r) {\n        switch (op) {\n            case T.Op.Equal: return l === r;\n        }\n    }\n\n    throw Error(`Incmpatible type of binary operator`);\n\n}\n\nexport function evalExpr(expr: T.Expr) {\n    return (w: T.Word): T.Result => {\n        switch (expr.type) {\n            case T.ExprType.Atom:\n                return evalAtom(expr, w);\n            case T.ExprType.Binop:\n                const lres = evalExpr(expr.l)(w);\n                const rres = evalExpr(expr.r)(w);\n                return evalBin(expr.op, lres, rres);\n        }\n    };\n}\n","import * as T from '../types';\nimport * as S from '../storage';\n\n\nexport function executeInsert(insertEntries: T.Insert[\"words\"]) {\n    let tags: { [t: string]: null; } = {};\n    let words: T.WordInfo[] = [];\n    insertEntries.forEach(e => {\n        if (Array.isArray(e)) {\n            e.forEach(t => { if (t in tags) { delete tags[t]; } else { tags[t] = null; } });\n        } else {\n            words.push({ ...e, tags: Object.keys(tags) });\n        }\n    });\n    return S.addWords(words);\n}\n","import * as T from '../types'\nimport * as S from '../storage'\nimport {evalExpr} from './expr'\n\ntype StmtFun = (ws: T.WordEntry[]) => Promise<T.WordEntry[]>\n\nasync function delStmt(ws: T.WordEntry[]){\n    await Promise.all(ws.map(w => S.delWord(w.key)))\n    return []\n}\n\nasync function clearStmt(ws: T.WordEntry[]){\n    return Promise.all(ws.map(w => S.clearWord(w.key).then(v => ({...w, value: v}))))\n}\n\nfunction changeTags(f: (k:T.Tag[])=>(k: string)=>Promise<T.Word>){\n    return function (tags: T.Tag[]): StmtFun{\n        return (ws: T.WordEntry[]) =>{\n            return Promise.all(\n                ws.map(w => f(tags)(w.key).then(v => ({...w, value: v})))\n            )\n        }\n    }\n}\n\nexport const pushTags = changeTags(S.pushTags)\nexport const popTags = changeTags(S.popTags)\n\nfunction sortBy<T>(a: T[], f: (e:T)=>number): T[]{\n    const values:[number, T][] = a.map(e => [f(e), e])\n    values.sort((e1, e2) => e1[0]-e2[0])\n    return values.map(e=>e[1])\n}\n\nfunction orderbyStmt(expr: T.Expr): StmtFun{\n    const compute = (w: T.WordEntry) => evalExpr(expr)(w.value) as number\n    return (ws: T.WordEntry[]) => new Promise(resolve => resolve(sortBy(ws, compute)))\n}\n\nfunction sliceStmt(start: number | undefined, end: number | undefined): StmtFun{\n\n    return (ws: T.WordEntry[]) => \n        new Promise(resolve => resolve(ws.slice(\n            start === undefined ? 0 : start, \n            end === undefined ? ws.length : end)))\n}\n\nconst id: StmtFun = ws => (new Promise(resolve => resolve(ws)))\n\nfunction execStmt(t: T.Stmt): StmtFun{\n    switch (t.type){\n        case T.StmtType.Delete:\n            return delStmt\n        case T.StmtType.Orderby:\n            return orderbyStmt(t.value)\n        case T.StmtType.Slice:\n            return sliceStmt(t.start, t.end)\n        case T.StmtType.Pushtags:\n            return pushTags(t.tags)\n        case T.StmtType.Poptags:\n            return popTags(t.tags)\n        case T.StmtType.Clear:\n            return clearStmt\n    }\n}\n\nfunction composeStmtFuns(fs: StmtFun[]): StmtFun{\n    return (ws: T.WordEntry[])=>{\n        let res = id(ws)\n        for(const f of fs){\n            res = res.then(f)\n        }\n        return res\n    }\n}\n\nexport async function execStmts(ts: T.Stmts, ws: T.WordEntry[]){\n    return await composeStmtFuns(ts.map(execStmt))(ws)\n}","import React from 'react'\nimport './modal.scss'\n\ntype Props = {content: JSX.Element | null, onClose: ()=>void}\nexport default ({content, onClose}: Props) =>{\n    if (content === null) {return (<></>)}\n    return(\n        <div \n            className=\"modal\" \n            // tabIndex={0}\n            onKeyDown={e=>{if (e.key===\"Escape\") onClose()}}\n        >\n            <div className=\"modal-content\">\n                {content}\n            </div>\n        </div>\n    )\n}\n","import * as S from '../storage'\n\nconst audio = new Audio()\n\nexport function stopAudio(){\n    audio.pause()\n    audio.currentTime=0\n}\n\nexport async function playAudio(key: string){\n    const chunks = await S.getAudio(key)\n    if (chunks.length > 0){\n        const blob = new Blob(chunks,  { 'type' : 'audio/ogg; codecs=opus' });\n        const audioURL = window.URL.createObjectURL(blob);\n        if (audio.src){\n            window.URL.revokeObjectURL(audio.src)\n        }\n        audio.src = audioURL\n        audio.play()    \n    }\n}\n\n","import * as S from '../storage'\n\nclass Recorder {\n    recorder: MediaRecorder | null\n    chunks: Blob[]\n    audio: HTMLAudioElement\n    key: string | null\n    constructor(){\n        this.recorder = null\n        this.chunks = []\n        this.audio = new Audio()\n        this.key = null\n    }\n\n    async setup(){\n        if (this.recorder === null){\n            const stream = await navigator.mediaDevices.getUserMedia({ audio: true })\n            this.recorder = new MediaRecorder(stream)\n            this.recorder.ondataavailable = e => {\n                if (e.data.size > 0){\n                    this.chunks.push(e.data)\n                }\n            }\n        }\n    }\n\n    _save(){\n        if (this.key !== null){\n            S.saveAudio(this.key, this.chunks)\n            this.key = null\n        }\n        this.chunks = []\n    }\n\n\n    async record(key: string){\n        await this.setup()\n        if (this.key !== null){\n            await this.save()\n        }\n        this.key = key\n        if (this.recorder){\n            this.recorder.start(10)\n        }\n    }\n\n    save(){\n        if (this.recorder && this.recorder.state===\"recording\"){\n            this.recorder.onstop = () => this._save()\n            this.recorder.stop()\n        }\n    }\n\n    startNew(key: string){\n        if (this.recorder && this.recorder.state===\"recording\"){\n            this.recorder.onstop = () => {\n                this._save()\n                this.record(key)\n            }\n            this.recorder.stop()\n            return true\n        }\n        return false\n    }\n}\n\nexport const recorder = new Recorder()","\nconst synth = window.speechSynthesis;\n\nexport function speak(t: string){\n    const utterThis = new SpeechSynthesisUtterance(t);\n    synth.speak(utterThis);\n}\n","import React, {useEffect, useRef, useState} from 'react'\nimport momentjs from 'moment'\nimport Modal from '../modal'\nimport * as T from '../../types'\nimport './wordcard.scss'\nimport Content, {Description} from '../word'\nimport * as A from '../../audio'\nimport Icon from '../icon'\nimport {getWordStem} from '../../utils'\n\n\ntype Props = {\n      word: T.WordEntry\n    , nextWord: ()=>void\n    , prevWord: ()=>void\n    , onClose: ()=>void\n    , review: ()=>void\n    , index: {widx: number, length: number}\n    , prevUnreviewed: ()=>void\n    , nextUnreviewed: ()=>void\n    , autoplay: boolean\n}\n\nexport default (props: Props) => {\n    const {word, onClose} = props\n    const card = word === null ? null : (<Card {...props}/>)\n    return(\n        <Modal content={card} onClose={onClose}/>\n    )\n}\n\nconst Card = ({word, prevWord: _prevWord, nextWord: _nextWord\n    , onClose, review, index, autoplay,\n    prevUnreviewed: _prevUnreviewed, \n    nextUnreviewed: _nextUnreviewed}: Props)=>{\n    const {key, value:{content, description, tags, lastreview, reviewtime, reviewed}} = word\n    const {widx, length} = index\n\n    const [uncover, setUncover] = useState(false)\n\n    const [recording, setRecording] = useState(false)\n    \n    const [mouseNav, setMouseNav] = useState(false)\n\n    const hasPrev = widx > 0\n    const hasNext = widx < length - 1\n    const disableCls = (test: boolean, cls: string) => cls + (test ? \" disabled\" :  \"\")\n    \n    const startRecording = () => {\n        if (!recording) A.recorder.record(key).then(()=>setRecording(true))\n    }\n\n    const doneRecording = () => {\n        if (recording){\n            setRecording(false)\n            A.recorder.save()\n        }\n    }\n\n    const play = () => {if (!recording) A.playAudio(key)}\n\n    useEffect(()=>{\n        if (!A.recorder.startNew(key) && autoplay){\n            play()\n        }\n    }, [key])\n\n    const changeAction= (act: ()=>void)=> (()=> \n        {  \n            setUncover(false)\n            act()\n        })\n    const prevWord = changeAction(_prevWord)\n    const nextWord = changeAction(_nextWord)\n    const nextUnreviewed = changeAction(_nextUnreviewed)\n    const prevUnreviewed = changeAction(_prevUnreviewed)\n\n\n    const since = momentjs(lastreview).fromNow()\n\n    const topRef = useRef(null as HTMLDivElement | null)\n\n    useEffect(()=>{\n        topRef.current?.focus()\n    }, [])\n\n    const handleKeydown = (e: React.KeyboardEvent<HTMLDivElement>) => {\n        switch (e.key){\n            case \"a\":\n                prevWord()\n                break\n            case \"s\":\n                review()\n                break\n            case \"d\":\n                nextWord()\n                break\n            case \"w\":\n                setUncover(!uncover)\n                break\n            case \"q\":\n                prevUnreviewed()\n                break\n            case \"e\":\n                nextUnreviewed()\n                break\n            case \"p\":\n                if (recording) doneRecording(); else startRecording()\n                break\n            case \"f\":\n                play()\n                break\n            case \"l\":\n                window.open(`https://forvo.com/word/${getWordStem(word.value.content)}/#ja`, 'forvowindow',\"height=600,width=600\")\n                break\n            case \"j\":\n                window.open(`https://jisho.org/search/${getWordStem(word.value.content)}`, 'jishowindow')\n                break\n            case 'x':\n                A.speak(word.value.description)\n                break\n            case 'm':\n                setMouseNav(!mouseNav)\n        }\n    }\n\n    const handleMouseEvent = (e: React.MouseEvent<HTMLDivElement>) => {\n        if (!mouseNav) return\n        switch (e.button){\n            case 0:\n                // left click\n                play()\n                break\n            case 4:\n                // scroll button right\n                review()\n                break\n        }\n    }\n\n    const handleWheelEvent = (e: React.WheelEvent<HTMLDivElement>) => {\n        if (!mouseNav) return\n        if (e.deltaY > 0){\n            if (e.deltaY < 10) {\n                setUncover(true)\n                A.speak(word.value.description)\n            }\n\n        } else {\n            if (e.deltaY > -10) nextWord()\n        }\n    }\n\n    return(\n        <div \n            className={reviewed? \"wordcard-wrapper reviewed\" : \"wordcard-wrapper\"}\n            onKeyDown={handleKeydown}\n            onMouseDown={handleMouseEvent}\n            onWheel={handleWheelEvent}\n            tabIndex={0}\n            ref={topRef}\n        >\n            <button className=\"close\" \n                    onClick={onClose}\n            >&times;</button>\n            <div className=\"info\">\n                Reviewed {since}\n            </div>\n            <div className=\"wordcard-nav\">\n\n                <div className=\"wordcard\">                    \n                    <div className={\"content\" + (uncover ? \" uncover\": \"\")}>\n                        <Content ps={content}/>\n                    </div>\n                    <div className=\"tags\">\n                        {tags.map((t, i)=><span key={i}>{t}</span>)}\n                    </div>\n                    <div className={\"description\" + (uncover ? \" uncover\": \"\")} >\n                        <Description desc={description}/>\n                    </div>\n                    <div className=\"buttons\">\n                        <button title=\"S\" disabled={reviewed} onClick={review}>Review {reviewtime}</button>\n                    </div>\n                </div>\n                <div className={disableCls(hasPrev, \"nav-left\")} onClick={prevWord} title=\"A\">\n                    <Icon icon=\"chevron-left\"/>\n                </div>\n                <div className={disableCls(hasNext, \"nav-right\")} onClick={nextWord} title=\"D\">\n                    <Icon icon=\"chevron-right\"/>\n                </div>\n                <div className =\"index\">                    \n                    {widx+1} / {length}\n                    <span className={\"mic\" + (recording ? \" active\" : \"\")}><Icon icon=\"microphone\"/></span>\n                </div>\n            </div>\n        </div>\n    )\n}\n","import React, {useState, useEffect, useReducer} from 'react';\nimport * as T from '../../types'\nimport Word from '../word'\nimport Header from './header'\nimport './wordTable.scss'\nimport * as S from '../../storage'\nimport * as Q from '../../query'\nimport WordCard from '../wordcard'\nimport Icon from '../icon'\nimport {downloadVocabulary, download} from '../../utils'\nimport ReactDragListView from 'react-drag-listview'\n\ntype Props = {}\n\nfunction counter(n: number){\n    const reducer = (s: number, q: number | undefined) => \n        q === undefined ? (s + 1) % n : q\n    return reducer\n}\n\nconst [CONTENT, DESCRIPT] = [1, 2]\n\nexport default ({}: Props) => {\n    const [words, setWords] = useState([] as T.WordEntry[])\n    const [autoplay, setAutoplay] = useState(false)\n    const [mask, nextMask] = useReducer(counter(4), 0)\n    const [widx, _setWIdx] = useState(null as number | null)\n    const [refreshSt, refresh] = useState(false)\n    const [editing, setEditing] = useState(null as number | null)\n    const [vocabSize, setVocabSize] = useState(0)\n    const [busy, setBusy] = useState(false)\n    const [buffer, setBuffer] = useState(100)\n\n    useEffect(()=>{S.vocabularySize().then(setVocabSize)})\n\n    const init = () => {S.listWords().then(ws => setWords(ws))}\n\n    useEffect(init, [])\n\n    const setWIdx = (i: number | null) => {\n        if (i === null) _setWIdx(null)\n        else if (0 <= i && i < words.length) _setWIdx(i)\n    }\n\n    const addWord = (w: T.WordInfo) => {\n        return S.addWord(w).then(wi => setWords([wi, ...words]))\n    }\n\n    const editWord = (i: number) => {\n        const key = words[i].key\n        return (w: T.WordInfo) => {\n            return S.updateWord(key, ow => ({...ow, ...w}))\n            .then((nw)=>{words[i].value=nw;refresh(!refreshSt)})\n        }\n    }\n\n    const delWord = (i: number) => {\n        return () => {\n            S.delWord(words[i].key).then(() => {\n                setWords(words.filter((_,j)=>i!==j))\n            })\n        }\n    }\n\n    const review = (i: number | null) => {\n        if (i !==null && !words[i].value.reviewed) {\n            const key = words[i].key\n            S.reviewWord(key)\n            .then((nw)=>{\n                words[i]={key, value: nw}\n                refresh(!refreshSt)\n            })\n        }\n    }\n\n    const executeQuery = (query: T.Query) => {\n        // console.log(query)\n        setBusy(true)\n        let task: Promise<void>\n        switch(query.type){\n            case \"Insert\":\n                task = Q.executeInsert(query.words).then(\n                    newwords => {\n                        setWords([...newwords, ...words])\n                    }\n                )\n                break\n            case \"Filter\":\n                task = S.listWords(Q.evalExpr(query.expr) as (w: T.Word)=>boolean)\n                    .then(ws => Q.execStmts(query.stmts, ws))\n                    .then(setWords)\n                break\n            case \"NewSession\":\n                task = S.newSession().then(init)\n                break\n            case \"Dump\":\n                S.dumpDb()\n                .then(s => download(new Date().toISOString()+\".txt\", s))\n                task = new Promise((resolve)=>resolve())\n                break\n        }\n        task.then(()=>setBusy(false))\n    }\n\n    const nextUnreviewed = () => {\n        if (widx !== null){\n            for(let i = widx+1; i < words.length; i ++){\n                if (!words[i].value.reviewed) {\n                    setWIdx(i)\n                    break\n                }\n            }\n            \n        }\n    }\n\n    const prevUnreviewed = () => {\n        if (widx !== null){\n            for(let i = widx-1; i >= 0; i --){\n                if (!words[i].value.reviewed){\n                    setWIdx(i)\n                    break\n                }\n            }\n        }\n    }\n\n    const dragProps = {\n        onDragEnd(fromIndex: number, toIndex: number) {\n            const item = words.splice(fromIndex, 1)[0];\n            words.splice(toIndex, 0, item);\n            refresh(!refreshSt)\n        },\n        nodeSelector: 'tr',\n        handleSelector: 'a'\n      };\n    return(\n        <div className={\n            (mask & CONTENT? \"hide\" : \"\") + \n            (busy? \" busy\" : \"\") + \n            (mask & DESCRIPT? \" hidedef\" : \"\")}\n        >\n        <div className=\"vocabulary\">\n            <Header \n                addWord={editing === null ? addWord : editWord(editing)}\n                init={editing === null ? null : words[editing].value}\n                cancel={()=>setEditing(null)}\n                toggleHide={()=>nextMask(undefined)}\n                query={executeQuery}\n                export={()=>downloadVocabulary(words)}\n                autoplay={autoplay}\n                toggleAP={()=>setAutoplay(!autoplay)}\n            />\n            <div className=\"table_info\">\n                {words.length} out of {vocabSize} words selected.\n            </div>\n            <ReactDragListView {...dragProps}>\n            <table className=\"word-table\">\n                <thead>\n                    <tr>\n                        <th>Word</th>\n                        <th>Description</th>\n                        <th>Tags</th>\n                    </tr>\n                </thead>\n                <tbody>\n                    {words.slice(0, buffer).map((w, i) => (\n                        <Entry \n                            word={w} \n                            key={w.key}\n                            activate={()=>{setWIdx(i)}}\n                            del={delWord(i)}\n                            review={()=>review(i)}\n                            edit={()=>setEditing(i)}\n                            idx={i}\n                        />))\n                    }\n                </tbody>\n            </table>\n            </ReactDragListView>\n            {buffer < words.length ? ( \n                <div className=\"load\" onClick={()=>{setBuffer(buffer+50)}}>\n                    Load More\n                </div>)\n                : <React.Fragment/>\n            }\n        </div>\n        {(widx!==null)?\n        <WordCard\n            onClose={()=>{setWIdx(null)}}\n            nextWord={()=>{setWIdx(widx+1)}}\n            prevWord={()=>{setWIdx(widx-1)}}\n            review={()=>review(widx)}\n            word={words[widx]}\n            index={{widx, length: words.length}}\n            prevUnreviewed={prevUnreviewed}\n            nextUnreviewed={nextUnreviewed}\n            autoplay={autoplay}\n        />: <></>}\n        </div>\n    )\n}\n\n\nconst Entry = ({\n    word, activate, del, review, edit, idx}: \n    {word: T.WordEntry, activate: ()=>void\n        , del: ()=>void, review: ()=>void, edit: ()=>void\n        ,idx: number\n    }) => {\n    const {content, tags, description} = word.value\n    const reviewed = word.value.reviewed\n    return(\n        <tr onClick={activate} className={reviewed ? \"reviewed\" : \"\"}>\n            <td>\n                <a onClick={e=>e.stopPropagation()}/>\n                <div className=\"content\">{<Word ps={content}/>}</div>\n            </td>\n            <td><div className=\"description\">{description}</div></td>\n            <td valign=\"top\">\n                <div className=\"tags\">\n                    {tags.map((t, i)=><span key={i}>{t}</span>)}\n                </div>\n            </td>\n            <td onClick={e=>e.stopPropagation()}>\n                <Controls idx={idx} del={del} review={review} reviewed={reviewed} edit={edit}/>\n            </td>\n        </tr>\n    )\n}\n\n\nconst Controls = ({del, review, reviewed, edit, idx}\n                : {del: ()=>void, review: ()=>void\n                    , reviewed: boolean, edit: ()=>void\n                    , idx: number\n                }) => \n{\n    return(\n        <div className=\"controls\">\n            <button \n                className=\"edit\"\n                onClick={edit}\n            ><Icon icon=\"pen-alt\"/></button>\n            <button \n                className=\"review\"\n                onClick={review}\n            ><Icon icon={reviewed ? \"book-open\" : \"book\"}/></button>\n            <button \n                className=\"delete\"\n                onDoubleClick={del}\n                ><Icon icon=\"trash-alt\"/>\n            </button>\n            <span className=\"rownumber\">{idx+1}</span>\n        </div>\n    )\n}\n","import React from 'react';\nimport WordTable from './components/wordTable/wordTable'\nimport './App.css';\n\n\nfunction App() {\n  window.onbeforeunload = function() { return \"Your work will be lost.\"; };\n  return (\n    <div className=\"app\">\n      <WordTable/>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}